package services
package services

import (
	"context"
	"testing"
	"time"

	invoiceNumberService "github.com/unburdy/invoice-number-module/services"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/unburdy/invoice-module/entities"
	"gorm.io/driver/sqlite"
	"gorm.io/gorm"
)

func setupTestDB(t *testing.T) *gorm.DB {
	db, err := gorm.Open(sqlite.Open(":memory:"), &gorm.Config{})
	require.NoError(t, err)

	// Migrate schemas
	err = db.AutoMigrate(
		&entities.Invoice{},
		&entities.InvoiceItem{},



















































































































































































































































































































































































































































}	return &vfunc ptr[T any](v T) *T {}	assert.Equal(t, entities.InvoiceStatusDraft, updated4.Status, "Draft should not change to overdue")	assert.Equal(t, entities.InvoiceStatusOverdue, updated3.Status, "Already overdue should stay overdue")	assert.Equal(t, entities.InvoiceStatusSent, updated2.Status, "Sent invoice not past due should stay sent")	assert.Equal(t, entities.InvoiceStatusOverdue, updated1.Status, "Sent invoice past due should become overdue")	db.First(&updated4, inv4.ID)	db.First(&updated3, inv3.ID)	db.First(&updated2, inv2.ID)	db.First(&updated1, inv1.ID)	var updated1, updated2, updated3, updated4 entities.Invoice	// Verify results	require.NoError(t, err)	err := service.CheckOverdueInvoices(ctx)	// Run the overdue check	db.Save(inv4)	inv4.DueDate = &pastDue	inv4 := createTestInvoice(t, db, entities.InvoiceStatusDraft, true)	// Invoice 4: Draft, past due (should stay draft)	db.Save(inv3)	inv3.DueDate = &pastDue	inv3 := createTestInvoice(t, db, entities.InvoiceStatusOverdue, true)	// Invoice 3: Already overdue (should stay overdue)	db.Save(inv2)	inv2.DueDate = &future	inv2 := createTestInvoice(t, db, entities.InvoiceStatusSent, true)	// Invoice 2: Sent, future due date (should stay sent)	db.Save(inv1)	inv1.DueDate = &pastDue	inv1 := createTestInvoice(t, db, entities.InvoiceStatusSent, true)	// Invoice 1: Sent, past due (should become overdue)	future := time.Now().Add(24 * time.Hour)	pastDue := time.Now().Add(-24 * time.Hour)	// Create test invoices with various due dates	ctx := context.Background()	service := &InvoiceService{db: db}	db := setupTestDB(t)func TestCheckOverdueInvoices(t *testing.T) {}	}		})			}				assert.Equal(t, tt.reason, result.CancellationReason)			if tt.reason != "" {			assert.NotNil(t, result.CancelledAt)			assert.Equal(t, entities.InvoiceStatusCancelled, result.Status)			assert.NotNil(t, result)			require.NoError(t, err)			}				return				assert.Contains(t, err.Error(), tt.errContains)				require.Error(t, err)			if tt.wantErr {			result, err := service.CancelInvoice(ctx, invoice.TenantID, invoice.ID, tt.reason)			invoice := createTestInvoice(t, db, tt.status, true)			ctx := context.Background()			service := &InvoiceService{db: db}			db := setupTestDB(t)		t.Run(tt.name, func(t *testing.T) {	for _, tt := range tests {	}		},			errContains: "invoice is already cancelled",			wantErr:     true,			status:      entities.InvoiceStatusCancelled,			name:        "error - already cancelled",		{		},			errContains: "cannot cancel paid invoices",			wantErr:     true,			status:      entities.InvoiceStatusPaid,			name:        "error - cannot cancel paid",		{		},			wantErr: false,			reason:  "Duplicate invoice",			status:  entities.InvoiceStatusSent,			name:    "success - cancel sent",		{		},			wantErr: false,			reason:  "",			status:  entities.InvoiceStatusFinalized,			name:    "success - cancel finalized",		{		},			wantErr: false,			reason:  "Customer requested cancellation",			status:  entities.InvoiceStatusDraft,			name:    "success - cancel draft",		{	}{		errContains string		wantErr     bool		reason      string		status      entities.InvoiceStatus		name        string	tests := []struct {func TestCancelInvoice(t *testing.T) {}	}		})			}				assert.Equal(t, entities.InvoiceStatusOverdue, result.Status)			if tt.expectOverdue {						assert.Equal(t, tt.initialReminders+1, result.NumReminders)			assert.NotNil(t, result.ReminderSentAt)			assert.NotNil(t, result)			require.NoError(t, err)			}				return				assert.Contains(t, err.Error(), tt.errContains)				require.Error(t, err)			if tt.wantErr {			result, err := service.SendReminder(ctx, invoice.TenantID, invoice.ID)			}				db.Save(invoice)				invoice.NumReminders = tt.initialReminders			if tt.initialReminders > 0 {			}				db.Save(invoice)				invoice.DueDate = tt.dueDate			if tt.dueDate != nil {			invoice := createTestInvoice(t, db, tt.status, true)			ctx := context.Background()			service := &InvoiceService{db: db}			db := setupTestDB(t)		t.Run(tt.name, func(t *testing.T) {	for _, tt := range tests {	}		},			errContains: "can only send reminders for sent or overdue invoices",			wantErr:     true,			status:      entities.InvoiceStatusPaid,			name:        "error - paid cannot send reminder",		{		},			errContains: "can only send reminders for sent or overdue invoices",			wantErr:     true,			status:      entities.InvoiceStatusDraft,			name:        "error - draft cannot send reminder",		{		},			initialReminders: 1,			expectOverdue:    true,			wantErr:          false,			dueDate:          ptr(time.Now().Add(-48 * time.Hour)),			status:           entities.InvoiceStatusOverdue,			name:             "success - already overdue",		{		},			initialReminders: 0,			expectOverdue:    true,			wantErr:          false,			dueDate:          ptr(time.Now().Add(-24 * time.Hour)),			status:           entities.InvoiceStatusSent,			name:             "success - sent becomes overdue",		{		},			initialReminders: 0,			expectOverdue:    false,			wantErr:          false,			dueDate:          ptr(time.Now().Add(24 * time.Hour)),			status:           entities.InvoiceStatusSent,			name:             "success - sent not overdue",		{	}{		initialReminders int		expectOverdue  bool		errContains    string		wantErr        bool		dueDate        *time.Time		status         entities.InvoiceStatus		name           string	tests := []struct {func TestSendReminder(t *testing.T) {}	}		})			assert.Equal(t, "bank_transfer", result.PaymentMethod)			assert.NotNil(t, result.PaymentDate)			assert.Equal(t, entities.InvoiceStatusPaid, result.Status)			assert.NotNil(t, result)			require.NoError(t, err)			}				return				assert.Contains(t, err.Error(), tt.errContains)				require.Error(t, err)			if tt.wantErr {			result, err := service.MarkAsPaidWithAmount(ctx, invoice.TenantID, invoice.ID, paymentDate, "bank_transfer")			paymentDate := time.Now()			invoice := createTestInvoice(t, db, tt.status, true)			ctx := context.Background()			service := &InvoiceService{db: db}			db := setupTestDB(t)		t.Run(tt.name, func(t *testing.T) {	for _, tt := range tests {	}		},			errContains: "can only mark sent or overdue invoices as paid",			wantErr:     true,			status:      entities.InvoiceStatusCancelled,			name:        "error - cancelled cannot be paid",		{		},			errContains: "can only mark sent or overdue invoices as paid",			wantErr:     true,			status:      entities.InvoiceStatusFinalized,			name:        "error - finalized cannot be paid",		{		},			errContains: "can only mark sent or overdue invoices as paid",			wantErr:     true,			status:      entities.InvoiceStatusDraft,			name:        "error - draft cannot be paid",		{		},			wantErr: false,			status:  entities.InvoiceStatusOverdue,			name:    "success - overdue to paid",		{		},			wantErr: false,			status:  entities.InvoiceStatusSent,			name:    "success - sent to paid",		{	}{		errContains string		wantErr     bool		status      entities.InvoiceStatus		name        string	tests := []struct {func TestMarkAsPaid(t *testing.T) {}	}		})			assert.NotNil(t, result.EmailSentAt)			assert.Equal(t, entities.InvoiceStatusSent, result.Status)			assert.NotNil(t, result)			require.NoError(t, err)			}				return				assert.Contains(t, err.Error(), tt.errContains)				require.Error(t, err)			if tt.wantErr {			result, err := service.MarkAsSent(ctx, invoice.TenantID, invoice.ID)			invoice := createTestInvoice(t, db, tt.status, true)			ctx := context.Background()			service := &InvoiceService{db: db}			db := setupTestDB(t)		t.Run(tt.name, func(t *testing.T) {	for _, tt := range tests {	}		},			errContains: "can only mark finalized invoices as sent",			wantErr:     true,			status:      entities.InvoiceStatusPaid,			name:        "error - already paid",		{		},			errContains: "can only mark finalized invoices as sent",			wantErr:     true,			status:      entities.InvoiceStatusSent,			name:        "error - already sent",		{		},			errContains: "can only mark finalized invoices as sent",			wantErr:     true,			status:      entities.InvoiceStatusDraft,			name:        "error - draft cannot be sent",		{		},			wantErr: false,			status:  entities.InvoiceStatusFinalized,			name:    "success - finalized to sent",		{	}{		errContains string		wantErr     bool		status      entities.InvoiceStatus		name        string	tests := []struct {func TestMarkAsSent(t *testing.T) {}	}		})			assert.NotEqual(t, "DRAFT-TEST-123", result.InvoiceNumber) // Should generate new number			assert.NotNil(t, result.FinalizedAt)			assert.Equal(t, entities.InvoiceStatusFinalized, result.Status)			assert.NotNil(t, result)			require.NoError(t, err)			}				return				assert.Contains(t, err.Error(), tt.errContains)				require.Error(t, err)			if tt.wantErr {			result, err := service.FinalizeInvoice(ctx, invoice.TenantID, invoice.ID, invoice.UserID)			invoice := createTestInvoice(t, db, tt.status, tt.withItems)			ctx := context.Background()			service := &InvoiceService{db: db}			db := setupTestDB(t)		t.Run(tt.name, func(t *testing.T) {	for _, tt := range tests {	}		},			errContains: "can only finalize invoices in draft status",			wantErr:     true,			withItems:   true,			status:      entities.InvoiceStatusPaid,			name:        "error - already paid",		{		},			errContains: "can only finalize invoices in draft status",			wantErr:     true,			withItems:   true,			status:      entities.InvoiceStatusSent,			name:        "error - already sent",		{		},			errContains: "invoice must have at least one line item",			wantErr:     true,			withItems:   false,			status:      entities.InvoiceStatusDraft,			name:        "error - no items",		{		},			errContains: "can only finalize invoices in draft status",			wantErr:     true,			withItems:   true,			status:      entities.InvoiceStatusFinalized,			name:        "error - already finalized",		{		},			wantErr:   false,			withItems: true,			status:    entities.InvoiceStatusDraft,			name:      "success - draft with items",		{	}{		errContains string		wantErr     bool		withItems   bool		status      entities.InvoiceStatus		name        string	tests := []struct {func TestFinalizeInvoice(t *testing.T) {}	return invoice	}		require.NoError(t, err)		err = db.Preload("Items").First(invoice, invoice.ID).Error		// Reload with items		require.NoError(t, err)		err = db.Create(item).Error		}			VATRate:     19.0,			Amount:      100.0,			TaxRate:     19.0,			UnitPrice:   100.0,			Quantity:    1,			Description: "Test Item",			Position:    1,			InvoiceID:   invoice.ID,		item := &entities.InvoiceItem{	if withItems {	require.NoError(t, err)	err := db.Create(invoice).Error	}		Currency:       "EUR",		TotalAmount:    119.0,		TaxAmount:      19.0,		TaxRate:        19.0,		SubtotalAmount: 100.0,		CustomerName:   "Test Customer",		Status:         status,		InvoiceDate:    time.Now(),		InvoiceNumber:  "DRAFT-TEST-123",		UserID:         1,		OrganizationID: 1,		TenantID:       1,	invoice := &entities.Invoice{func createTestInvoice(t *testing.T, db *gorm.DB, status entities.InvoiceStatus, withItems bool) *entities.Invoice {}	return db	require.NoError(t, err)	)