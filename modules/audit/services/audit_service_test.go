package services
package services_test

import (
	"testing"
	"time"

	"github.com/ae-base-server/pkg/testutils"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/unburdy/audit-module/entities"
	"github.com/unburdy/audit-module/services"
)

func TestAuditService_LogEvent(t *testing.T) {
	tests := []struct {
		name    string
		request services.LogEventRequest
		wantErr bool
	}{
		{
			name: "success - log invoice created",
			request: services.LogEventRequest{
				TenantID:   1,
				UserID:     10,
































































































































































































































































































































































}	return ids	}		ids = append(ids, uint(i+1))		time.Sleep(time.Millisecond)		// Sleep briefly to ensure different timestamps		require.NoError(t, err)		err := service.LogEvent(req)		}			UserAgent:  "TestAgent",			IPAddress:  "192.168.1.1",			Action:     actions[i%len(actions)],			EntityID:   uint(100 + i),			EntityType: entities.EntityTypeInvoice,			UserID:     userID,			TenantID:   tenantID,		req := services.LogEventRequest{	for i := 0; i < count; i++ {	}		entities.AuditActionInvoiceMarkedPaid,		entities.AuditActionInvoiceSent,		entities.AuditActionInvoiceFinalized,		entities.AuditActionInvoiceDraftUpdated,		entities.AuditActionInvoiceDraftCreated,	actions := []entities.AuditAction{	ids := make([]uint, 0, count)	t.Helper()func createTestAuditLogs(t *testing.T, service *services.AuditService, tenantID, userID uint, count int) []uint {// Helper function to create test audit logs}	assert.Equal(t, originalAction, verifyLog.Action, "Audit log should be immutable")	db.First(&verifyLog, log.ID)	var verifyLog entities.AuditLog	// For now, we verify the original log remains unchanged by re-fetching	// In a real implementation, you might have triggers or constraints preventing updates	log.Action = entities.AuditActionInvoiceFinalized	originalAction := log.Action	// Attempt to update the log (should ideally be prevented by database constraints)	db.First(&log)	var log entities.AuditLog	// Get the log	require.NoError(t, err)	err := service.LogEvent(req)	}		Action:     entities.AuditActionInvoiceDraftCreated,		EntityID:   100,		EntityType: entities.EntityTypeInvoice,		UserID:     10,		TenantID:   1,	req := services.LogEventRequest{	// Create an audit log	service := services.NewAuditService(db)	testutils.MigrateTestDB(t, db, &entities.AuditLog{})	defer testutils.CleanupTestDB(db)	db := testutils.SetupTestDB(t)func TestAuditService_Immutability(t *testing.T) {}	assert.Equal(t, int64(concurrency), count)	db.Model(&entities.AuditLog{}).Count(&count)	var count int64	// Verify all logs were created	}		require.NoError(t, err, "Concurrent write %d failed", i)		err := <-errChan	for i := 0; i < concurrency; i++ {	// Collect results	}		}(i)			errChan <- service.LogEvent(req)			}				IPAddress:  "192.168.1.1",				Action:     entities.AuditActionInvoiceDraftCreated,				EntityID:   uint(100 + index),				EntityType: entities.EntityTypeInvoice,				UserID:     uint(10 + index),				TenantID:   1,			req := services.LogEventRequest{		go func(index int) {	for i := 0; i < concurrency; i++ {	errChan := make(chan error, concurrency)	concurrency := 50	// Perform concurrent writes	service := services.NewAuditService(db)	testutils.MigrateTestDB(t, db, &entities.AuditLog{})	defer testutils.CleanupTestDB(db)	db := testutils.SetupTestDB(t)func TestAuditService_ConcurrentWrites(t *testing.T) {}	}		assert.Equal(t, uint(3), log.TenantID, "Tenant 3 should only see their own logs")	for _, log := range logs3 {	assert.Equal(t, int64(2), total3)	assert.Len(t, logs3, 2)	require.NoError(t, err)	})		Limit:    100,		Page:     1,		TenantID: 3,	logs3, total3, err := service.GetAuditLogs(entities.AuditLogFilter{	// Tenant 3 should only see their logs	}		assert.Equal(t, uint(2), log.TenantID, "Tenant 2 should only see their own logs")	for _, log := range logs2 {	assert.Equal(t, int64(3), total2)	assert.Len(t, logs2, 3)	require.NoError(t, err)	})		Limit:    100,		Page:     1,		TenantID: 2,	logs2, total2, err := service.GetAuditLogs(entities.AuditLogFilter{	// Tenant 2 should only see their logs	}		assert.Equal(t, uint(1), log.TenantID, "Tenant 1 should only see their own logs")	for _, log := range logs1 {	assert.Equal(t, int64(5), total1)	assert.Len(t, logs1, 5)	require.NoError(t, err)	})		Limit:    100,		Page:     1,		TenantID: 1,	logs1, total1, err := service.GetAuditLogs(entities.AuditLogFilter{	// Tenant 1 should only see their logs	_ = createTestAuditLogs(t, service, 3, 30, 2)	_ = createTestAuditLogs(t, service, 2, 20, 3)	_ = createTestAuditLogs(t, service, 1, 10, 5)	// Create logs for different tenants	service := services.NewAuditService(db)	testutils.MigrateTestDB(t, db, &entities.AuditLog{})	defer testutils.CleanupTestDB(db)	db := testutils.SetupTestDB(t)func TestAuditService_TenantIsolation(t *testing.T) {}	_ = tenant2Logs	_ = tenant1Logs	// Clean up (logs are already cleaned by defer)	}		})			}				assert.Equal(t, tt.filter.TenantID, log.TenantID)			for _, log := range logs {			// Verify tenant isolation			assert.Equal(t, tt.wantTotal, total)			assert.Len(t, logs, tt.wantCount)			require.NoError(t, err)			// Assert			logs, total, err := service.GetAuditLogs(tt.filter)			// Act		t.Run(tt.name, func(t *testing.T) {	for _, tt := range tests {	}		},			wantTotal: 5,			wantCount: 2,			},				Limit:    2,				Page:     2,				TenantID: 1,			filter: entities.AuditLogFilter{			name: "pagination - page 2",		{		},			wantTotal: 5,			wantCount: 2,			},				Limit:    2,				Page:     1,				TenantID: 1,			filter: entities.AuditLogFilter{			name: "pagination - page 1",		{		},			wantTotal: 1,			wantCount: 1,			},				Limit:    10,				Page:     1,				Action:   testutils.Ptr(entities.AuditActionInvoiceFinalized),				TenantID: 1,			filter: entities.AuditLogFilter{			name: "filter by action",		{		},			wantTotal: 5,			wantCount: 5,			},				Limit:      10,				Page:       1,				EntityType: testutils.Ptr(entities.EntityTypeInvoice),				TenantID:   1,			filter: entities.AuditLogFilter{			name: "filter by entity type",		{		},			wantTotal: 5,			wantCount: 5,			},				Limit:    10,				Page:     1,				UserID:   testutils.Ptr(uint(10)),				TenantID: 1,			filter: entities.AuditLogFilter{			name: "filter by user",		{		},			wantTotal: 3,			wantCount: 3,			},				Limit:    10,				Page:     1,				TenantID: 2,			filter: entities.AuditLogFilter{			name: "get all logs for tenant 2",		{		},			wantTotal: 5,			wantCount: 5,			},				Limit:    10,				Page:     1,				TenantID: 1,			filter: entities.AuditLogFilter{			name: "get all logs for tenant 1",		{	}{		wantTotal int64		wantCount int		filter    entities.AuditLogFilter		name      string	tests := []struct {	tenant2Logs := createTestAuditLogs(t, service, 2, 20, 3)	tenant1Logs := createTestAuditLogs(t, service, 1, 10, 5)	// Create test data	service := services.NewAuditService(db)	testutils.MigrateTestDB(t, db, &entities.AuditLog{})	defer testutils.CleanupTestDB(db)	db := testutils.SetupTestDB(t)func TestAuditService_GetAuditLogs(t *testing.T) {}	}		})			testutils.AssertTimeNotZero(t, log.CreatedAt)			assert.Equal(t, tt.request.UserAgent, log.UserAgent)			assert.Equal(t, tt.request.IPAddress, log.IPAddress)			assert.Equal(t, tt.request.Action, log.Action)			assert.Equal(t, tt.request.EntityID, log.EntityID)			assert.Equal(t, tt.request.EntityType, log.EntityType)			assert.Equal(t, tt.request.UserID, log.UserID)			assert.Equal(t, tt.request.TenantID, log.TenantID)			require.NoError(t, result.Error)			result := db.Where("entity_id = ? AND action = ?", tt.request.EntityID, tt.request.Action).First(&log)			var log entities.AuditLog			// Verify log was created			require.NoError(t, err)			}				return				require.Error(t, err)			if tt.wantErr {			// Assert			err := service.LogEvent(tt.request)			// Act			service := services.NewAuditService(db)			testutils.MigrateTestDB(t, db, &entities.AuditLog{})			defer testutils.CleanupTestDB(db)			db := testutils.SetupTestDB(t)			// Arrange		t.Run(tt.name, func(t *testing.T) {	for _, tt := range tests {	}		},			wantErr: false,			},				},					},						"email_sent_to":  "customer@example.com",						"reminder_count": 2,					Details: map[string]interface{}{				Metadata: &entities.AuditLogMetadata{				Action:     entities.AuditActionReminderSent,				EntityID:   100,				EntityType: entities.EntityTypeInvoice,				UserID:     10,				TenantID:   1,			request: services.LogEventRequest{			name: "success - log reminder sent",		{		},			wantErr: false,			},				UserAgent: "Mozilla/5.0",				IPAddress: "192.168.1.1",				},					Reason:   "Customer requested finalization",					NewValue: map[string]interface{}{"status": "finalized", "invoice_number": "2026-0001"},					OldValue: map[string]interface{}{"status": "draft"},				Metadata: &entities.AuditLogMetadata{				Action:     entities.AuditActionInvoiceFinalized,				EntityID:   100,				EntityType: entities.EntityTypeInvoice,				UserID:     10,				TenantID:   1,			request: services.LogEventRequest{			name: "success - log with metadata",		{		},			wantErr: false,			},				UserAgent:  "Mozilla/5.0",				IPAddress:  "192.168.1.1",				Action:     entities.AuditActionInvoiceDraftCreated,				EntityID:   100,				EntityType: entities.EntityTypeInvoice,