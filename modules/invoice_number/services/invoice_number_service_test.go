package services
package services_test

import (
	"context"
	"fmt"
	"sync"
	"testing"
	"time"

	"github.com/ae-base-server/pkg/testutils"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/unburdy/invoice-number-module/entities"
	"github.com/unburdy/invoice-number-module/services"
)

// TestInvoiceNumberService_BasicGeneration tests basic invoice number generation
func TestInvoiceNumberService_BasicGeneration(t *testing.T) {
	db := testutils.SetupTestDB(t)
	defer testutils.CleanupTestDB(db)
	testutils.MigrateTestDB(t, db, 
		&entities.InvoiceNumber{},
		&entities.InvoiceNumberLog{},
	)




















































































































































































































































































































































































































































































































































































































































}	})		}			}				b.Fatal(err)			if err != nil {			_, err := service.GenerateInvoiceNumber(ctx, tenantID, orgID, config)		for pb.Next() {	b.RunParallel(func(pb *testing.PB) {	b.ResetTimer()	orgID := uint(1)	tenantID := uint(1)	config := services.DefaultInvoiceConfig()	service := services.NewInvoiceNumberService(db)	ctx := context.Background()	)		&entities.InvoiceNumberLog{},		&entities.InvoiceNumber{},	testutils.MigrateTestDB(&testing.T{}, db, 	defer testutils.CleanupTestDB(db)	db := testutils.SetupTestDB(&testing.T{})func BenchmarkConcurrentGeneration(b *testing.B) {// BenchmarkConcurrentGeneration benchmarks concurrent invoice number generation}	}		}			b.Fatal(err)		if err != nil {		_, err := service.GenerateInvoiceNumber(ctx, tenantID, orgID, config)	for i := 0; i < b.N; i++ {	b.ResetTimer()	orgID := uint(1)	tenantID := uint(1)	config := services.DefaultInvoiceConfig()	service := services.NewInvoiceNumberService(db)	ctx := context.Background()	)		&entities.InvoiceNumberLog{},		&entities.InvoiceNumber{},	testutils.MigrateTestDB(&testing.T{}, db, 	defer testutils.CleanupTestDB(db)	db := testutils.SetupTestDB(&testing.T{})func BenchmarkInvoiceNumberGeneration(b *testing.B) {// BenchmarkInvoiceNumberGeneration benchmarks invoice number generation}	})		assert.Less(t, duration.Milliseconds(), int64(5000), "Should complete in under 5 seconds")		// Should be reasonably fast even without Redis				t.Logf("Sequential: %d numbers in %v (%.0f/sec)", count, duration, rate)				rate := float64(count) / duration.Seconds()		duration := time.Since(start)		}			require.NoError(t, err)			_, err := service.GenerateInvoiceNumber(ctx, tenantID, orgID, config)		for i := 0; i < count; i++ {		start := time.Now()		const count = 100	t.Run("sequential performance baseline", func(t *testing.T) {	orgID := uint(1)	tenantID := uint(1)	config := services.DefaultInvoiceConfig()	service := services.NewInvoiceNumberService(db)	ctx := context.Background()	)		&entities.InvoiceNumberLog{},		&entities.InvoiceNumber{},	testutils.MigrateTestDB(t, db, 	defer testutils.CleanupTestDB(db)	db := testutils.SetupTestDB(t)	}		t.Skip("Skipping performance test in short mode")	if testing.Short() {func TestInvoiceNumberService_Performance(t *testing.T) {// TestInvoiceNumberService_Performance benchmarks performance characteristics}	})		}			assert.Equal(t, uint(1), log.TenantID)		for _, log := range history {		assert.Equal(t, int64(15), total) // Only tenant 1's 15 numbers		require.NoError(t, err)		history, total, err := service.GetInvoiceNumberHistory(ctx, 1, orgID, year, month, 1, 100)		// Tenant 1 should not see tenant 2's history		month := int(time.Now().Month())		year := time.Now().Year()		require.NoError(t, err)		_, err := service.GenerateInvoiceNumber(ctx, 2, orgID, config)		// Generate for tenant 2	t.Run("tenant isolation in history", func(t *testing.T) {	})		assert.Equal(t, int64(15), total)		assert.Len(t, history, 5)		require.NoError(t, err)		history, total, err = service.GetInvoiceNumberHistory(ctx, tenantID, orgID, year, month, 2, 10)		// Get page 2 (5 items)		assert.Equal(t, int64(15), total)		assert.Len(t, history, 10)		require.NoError(t, err)		history, total, err := service.GetInvoiceNumberHistory(ctx, tenantID, orgID, year, month, 1, 10)		// Get page 1 (10 items)		month := int(time.Now().Month())		year := time.Now().Year()		}			require.NoError(t, err)			_, err := service.GenerateInvoiceNumber(ctx, tenantID, orgID, config)		for i := 0; i < 15; i++ {		// Generate 15 numbers	t.Run("retrieves paginated history", func(t *testing.T) {	orgID := uint(1)	tenantID := uint(1)	config := services.DefaultInvoiceConfig()	service := services.NewInvoiceNumberService(db)	ctx := context.Background()	)		&entities.InvoiceNumberLog{},		&entities.InvoiceNumber{},	testutils.MigrateTestDB(t, db, 	defer testutils.CleanupTestDB(db)	db := testutils.SetupTestDB(t)func TestInvoiceNumberService_History(t *testing.T) {// TestInvoiceNumberService_History tests invoice number history retrieval}	})		assert.Equal(t, 3, seq)		require.NoError(t, err)		seq, err = service.GetCurrentSequence(ctx, tenantID, orgID, year, month)		// Call again - should still be 3 (not incremented)		assert.Equal(t, 3, seq)		require.NoError(t, err)		seq, err := service.GetCurrentSequence(ctx, tenantID, orgID, year, month)		month := int(time.Now().Month())		year := time.Now().Year()		}			require.NoError(t, err)			_, err := service.GenerateInvoiceNumber(ctx, tenantID, orgID, config)		for i := 0; i < 3; i++ {		// Generate 3 numbers	t.Run("returns current sequence after generation", func(t *testing.T) {	})		assert.Equal(t, 0, seq)		require.NoError(t, err)		seq, err := service.GetCurrentSequence(ctx, tenantID, orgID, year, month)		month := int(time.Now().Month())		year := time.Now().Year()	t.Run("returns 0 for new organization", func(t *testing.T) {	orgID := uint(1)	tenantID := uint(1)	config := services.DefaultInvoiceConfig()	service := services.NewInvoiceNumberService(db)	ctx := context.Background()	)		&entities.InvoiceNumberLog{},		&entities.InvoiceNumber{},	testutils.MigrateTestDB(t, db, 	defer testutils.CleanupTestDB(db)	db := testutils.SetupTestDB(t)func TestInvoiceNumberService_GetCurrentSequence(t *testing.T) {// TestInvoiceNumberService_GetCurrentSequence tests getting current sequence without incrementing}	})		assert.Error(t, err)		err = service.VoidInvoiceNumber(ctx, 2, result.InvoiceNumber)		// Tenant 2 cannot void tenant 1's number		require.NoError(t, err)		result, err := service.GenerateInvoiceNumber(ctx, 1, orgID, config)		// Generate for tenant 1	t.Run("tenant isolation on void", func(t *testing.T) {	})		assert.Error(t, err)		err := service.VoidInvoiceNumber(ctx, tenantID, "NONEXISTENT-123")	t.Run("cannot void non-existent invoice number", func(t *testing.T) {	})		assert.Equal(t, "voided", log.Status)		require.NoError(t, err)		err = db.Where("invoice_number = ?", invoiceNumber).First(&log).Error		var log entities.InvoiceNumberLog		// Verify status is voided		require.NoError(t, err)		err = service.VoidInvoiceNumber(ctx, tenantID, invoiceNumber)		// Void it		invoiceNumber := result.InvoiceNumber		require.NoError(t, err)		result, err := service.GenerateInvoiceNumber(ctx, tenantID, orgID, config)		// Generate number	t.Run("can void invoice number", func(t *testing.T) {	orgID := uint(1)	tenantID := uint(1)	config := services.DefaultInvoiceConfig()	service := services.NewInvoiceNumberService(db)	ctx := context.Background()	)		&entities.InvoiceNumberLog{},		&entities.InvoiceNumber{},	testutils.MigrateTestDB(t, db, 	defer testutils.CleanupTestDB(db)	db := testutils.SetupTestDB(t)func TestInvoiceNumberService_VoidInvoiceNumber(t *testing.T) {// TestInvoiceNumberService_VoidInvoiceNumber tests voiding invoice numbers}	})		assert.Equal(t, 5, record.Sequence)		require.NoError(t, err)			tenantID, orgID, currentYear, currentMonth).First(&record).Error		err := db.Where("tenant_id = ? AND organization_id = ? AND year = ? AND month = ?", 				currentMonth := int(time.Now().Month())		currentYear := time.Now().Year()		var record entities.InvoiceNumber		// Verify monthly tracking		}			assert.Equal(t, i+1, result.Sequence)			require.NoError(t, err)			result, err := service.GenerateInvoiceNumber(ctx, tenantID, orgID, config)		for i := 0; i < 5; i++ {		// Generate 5 numbers		}			ResetMonthly: true,			Separator:    "-",			Padding:      4,			MonthFormat:  "MM",			YearFormat:   "YYYY",			Prefix:       "INV",		config := services.InvoiceNumberConfig{	t.Run("monthly reset configuration", func(t *testing.T) {	orgID := uint(1)	tenantID := uint(1)	service := services.NewInvoiceNumberService(db)	ctx := context.Background()	)		&entities.InvoiceNumberLog{},		&entities.InvoiceNumber{},	testutils.MigrateTestDB(t, db, 	defer testutils.CleanupTestDB(db)	db := testutils.SetupTestDB(t)func TestInvoiceNumberService_MonthlyReset(t *testing.T) {// TestInvoiceNumberService_MonthlyReset tests monthly sequence reset}	})		assert.Equal(t, 3, record.Sequence)		require.NoError(t, err)			tenantID, orgID, currentYear).First(&record).Error		err := db.Where("tenant_id = ? AND organization_id = ? AND year = ?", 		currentYear := time.Now().Year()		var record entities.InvoiceNumber		// Verify invoice_numbers table has entry for current year				// For now, we verify the logic by checking different year/month entries		// Note: Testing year rollover requires mocking time.Now()		}			assert.Equal(t, i+1, result.Sequence)			require.NoError(t, err)			result, err := service.GenerateInvoiceNumber(ctx, tenantID, orgID, config)		for i := 0; i < 3; i++ {		// Simulate generating 3 numbers in 2025		}			ResetMonthly: false,			Separator:    "-",			Padding:      4,			YearFormat:   "YYYY",			Prefix:       "INV",		config := services.InvoiceNumberConfig{		// Generate number for 2025	t.Run("sequence resets for new year", func(t *testing.T) {	orgID := uint(1)	tenantID := uint(1)	service := services.NewInvoiceNumberService(db)	ctx := context.Background()	)		&entities.InvoiceNumberLog{},		&entities.InvoiceNumber{},	testutils.MigrateTestDB(t, db, 	defer testutils.CleanupTestDB(db)	db := testutils.SetupTestDB(t)func TestInvoiceNumberService_YearlyReset(t *testing.T) {// TestInvoiceNumberService_YearlyReset tests yearly sequence reset}	})		assert.Equal(t, int64(concurrency), logCount, "All numbers should be logged")			Count(&logCount)			Where("tenant_id = ? AND organization_id = ?", tenantID, orgID).		db.Model(&entities.InvoiceNumberLog{}).		var logCount int64		// Verify database integrity		}			assert.True(t, sequences[i], "Missing sequence number: %d", i)		for i := 1; i <= concurrency; i++ {		// Verify sequences are 1 through concurrency		assert.Len(t, sequences, concurrency)		assert.Len(t, invoiceNumbers, concurrency)		// Verify we got all unique numbers		}			sequences[result.Sequence] = true				"Duplicate sequence number: %d", result.Sequence)			assert.False(t, sequences[result.Sequence],			// Check for duplicate sequences			invoiceNumbers[result.InvoiceNumber] = true				"Duplicate invoice number generated: %s", result.InvoiceNumber)			assert.False(t, invoiceNumbers[result.InvoiceNumber], 			// Check for duplicate invoice numbers		for result := range results {		sequences := make(map[int]bool)		invoiceNumbers := make(map[string]bool)		// Collect all invoice numbers		assert.Equal(t, 0, errorCount, "No errors should occur during concurrent generation")		}			errorCount++			t.Errorf("Concurrent generation error: %v", err)		for err := range errors {		errorCount := 0		// Check for errors		t.Logf("Generated %d invoice numbers in %v (%.0f/sec)", concurrency, duration, float64(concurrency)/duration.Seconds())		duration := time.Since(startTime)		close(errors)		close(results)		wg.Wait()		}			}(i)				results <- result				}					return					errors <- err				if err != nil {				result, err := service.GenerateInvoiceNumber(ctx, tenantID, orgID, config)				defer wg.Done()			go func(idx int) {			wg.Add(1)		for i := 0; i < concurrency; i++ {		// Spawn concurrent goroutines		startTime := time.Now()		var wg sync.WaitGroup				errors := make(chan error, concurrency)		results := make(chan *entities.InvoiceNumberResponse, concurrency)		const concurrency = 100	t.Run("100 concurrent requests generate unique sequential numbers", func(t *testing.T) {	orgID := uint(1)	tenantID := uint(1)	config := services.DefaultInvoiceConfig()	service := services.NewInvoiceNumberService(db)	ctx := context.Background()	)		&entities.InvoiceNumberLog{},		&entities.InvoiceNumber{},	testutils.MigrateTestDB(t, db, 	defer testutils.CleanupTestDB(db)	db := testutils.SetupTestDB(t)func TestInvoiceNumberService_ConcurrentGeneration(t *testing.T) {// This is CRITICAL for GoBD compliance - no duplicate invoice numbers allowed// TestInvoiceNumberService_ConcurrentGeneration tests thread-safety under high concurrency}	})		assert.Equal(t, 4, result.Sequence)		require.NoError(t, err)		result, err = service.GenerateInvoiceNumber(ctx, tenantID, 1, config)		// Org 1 continues from 4		assert.Equal(t, 1, result.Sequence)		require.NoError(t, err)		result, err := service.GenerateInvoiceNumber(ctx, tenantID, 2, config)		// Org 2 starts from 1		}			assert.Equal(t, i+1, result.Sequence)			require.NoError(t, err)			result, err := service.GenerateInvoiceNumber(ctx, tenantID, 1, config)		for i := 0; i < 3; i++ {		// Org 1 generates 3 numbers	t.Run("different organizations have independent sequences", func(t *testing.T) {	tenantID := uint(1)	config := services.DefaultInvoiceConfig()	service := services.NewInvoiceNumberService(db)	ctx := context.Background()	)		&entities.InvoiceNumberLog{},		&entities.InvoiceNumber{},	testutils.MigrateTestDB(t, db, 	defer testutils.CleanupTestDB(db)	db := testutils.SetupTestDB(t)func TestInvoiceNumberService_OrganizationIsolation(t *testing.T) {// TestInvoiceNumberService_OrganizationIsolation tests multi-organization isolation}	})		}			assert.Equal(t, uint(2), log.TenantID)		for _, log := range tenant2Logs {		}			assert.Equal(t, uint(1), log.TenantID)		for _, log := range tenant1Logs {		// Verify no cross-contamination		assert.Len(t, tenant2Logs, 1)		db.Where("tenant_id = ?", 2).Find(&tenant2Logs)		var tenant2Logs []entities.InvoiceNumberLog		assert.Len(t, tenant1Logs, 6) // 5 + 1		db.Where("tenant_id = ?", 1).Find(&tenant1Logs)		var tenant1Logs []entities.InvoiceNumberLog	t.Run("tenant cannot see other tenant's logs", func(t *testing.T) {	})		assert.Equal(t, 1, result.Sequence)		require.NoError(t, err)		result, err = service.GenerateInvoiceNumber(ctx, 3, 1, config)		// Tenant 3 starts from 1		assert.Equal(t, 6, result.Sequence)		require.NoError(t, err)		result, err = service.GenerateInvoiceNumber(ctx, 1, 1, config)		// Tenant 1 continues from 6		assert.Equal(t, 1, result.Sequence)		require.NoError(t, err)		result, err := service.GenerateInvoiceNumber(ctx, 2, 1, config)		// Tenant 2 starts from 1		}			assert.Equal(t, i+1, result.Sequence)			require.NoError(t, err)			result, err := service.GenerateInvoiceNumber(ctx, 1, 1, config)		for i := 0; i < 5; i++ {		// Tenant 1 generates 5 numbers	t.Run("different tenants have independent sequences", func(t *testing.T) {	config := services.DefaultInvoiceConfig()	service := services.NewInvoiceNumberService(db)	ctx := context.Background()	)		&entities.InvoiceNumberLog{},		&entities.InvoiceNumber{},	testutils.MigrateTestDB(t, db, 	defer testutils.CleanupTestDB(db)	db := testutils.SetupTestDB(t)func TestInvoiceNumberService_TenantIsolation(t *testing.T) {// TestInvoiceNumberService_TenantIsolation tests multi-tenant isolation}	})		assert.Equal(t, int64(count), logCount)			Count(&logCount)			Where("tenant_id = ? AND organization_id = ?", tenantID, orgID).		db.Model(&entities.InvoiceNumberLog{}).		var logCount int64		// Verify all logged		assert.Len(t, uniqueMap, count)		}			uniqueMap[num] = true			assert.False(t, uniqueMap[num], "Duplicate invoice number: %s", num)		for _, num := range numbers {		uniqueMap := make(map[string]bool)		// Verify all numbers are unique		}			assert.Equal(t, i+1, result.Sequence)			numbers[i] = result.InvoiceNumber						require.NoError(t, err)			result, err := service.GenerateInvoiceNumber(ctx, tenantID, orgID, config)		for i := 0; i < count; i++ {		numbers := make([]string, count)		const count = 20	t.Run("generates sequential numbers without gaps", func(t *testing.T) {	orgID := uint(1)	tenantID := uint(1)	config := services.DefaultInvoiceConfig()	service := services.NewInvoiceNumberService(db)	ctx := context.Background()	)		&entities.InvoiceNumberLog{},		&entities.InvoiceNumber{},	testutils.MigrateTestDB(t, db, 	defer testutils.CleanupTestDB(db)	db := testutils.SetupTestDB(t)func TestInvoiceNumberService_SequentialGeneration(t *testing.T) {// TestInvoiceNumberService_SequentialGeneration tests sequential number generation}	}		})			assert.Equal(t, orgID, log.OrganizationID)			assert.Equal(t, tenantID, log.TenantID)			assert.Equal(t, "active", log.Status)			require.NoError(t, err)			err = db.Where("invoice_number = ?", result.InvoiceNumber).First(&log).Error			var log entities.InvoiceNumberLog			// Verify it was logged			assert.Equal(t, 1, result.Sequence)			assert.Equal(t, tt.expectedFormat, result.Format)			assert.Contains(t, result.InvoiceNumber, tt.expectedPrefix)			assert.NotEmpty(t, result.InvoiceNumber)			// Verify invoice number format			require.NotNil(t, result)			require.NoError(t, err)			result, err := service.GenerateInvoiceNumber(ctx, tenantID, orgID, tt.config)			orgID := uint(time.Now().UnixNano() % 100000)			tenantID := uint(time.Now().UnixNano() % 100000)			// Use unique tenant/org per test		t.Run(tt.name, func(t *testing.T) {	for _, tt := range tests {	}		},			expectedPrefix: "INV",			expectedFormat: "INV-YYYY-NNNNNN",			},				ResetMonthly: false,				Separator:    "-",				Padding:      6,				YearFormat:   "YYYY",				Prefix:       "INV",			config: services.InvoiceNumberConfig{			name: "short padding",		{		},			expectedPrefix: "RCH",			expectedFormat: "RCH-YYYY-NNNN",			},				ResetMonthly: false,				Separator:    "-",				Padding:      4,				YearFormat:   "YYYY",				Prefix:       "RCH",			config: services.InvoiceNumberConfig{			name: "custom prefix",		{		},			expectedPrefix: "INV",			expectedFormat: "INV-YYYY-NNNN",			config: services.DefaultInvoiceConfig(),			name: "default configuration generates INV-YYYY-NNNN format",		{	}{		expectedPrefix string		expectedFormat string		config         services.InvoiceNumberConfig		name           string	tests := []struct {	service := services.NewInvoiceNumberService(db)	ctx := context.Background()