package gobd_test

import (
	"context"
	"testing"
	"time"

	"github.com/ae-base-server/pkg/testutils"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/unburdy/invoice-module/entities"
	"github.com/unburdy/invoice-module/services"
	invoiceNumberService "github.com/unburdy/unburdy-server-api/modules/client_management/services"
	"gorm.io/gorm"
)

// TestGoBD_Immutability tests that finalized invoices cannot be modified



























































































































































































































































































































































































































































































}	return invoice	}		require.NoError(t, err)		err = db.Create(item).Error		}			TaxRate:     19.0,			VATRate:     19.0,			Amount:      100.00,			UnitPrice:   100.00,			Quantity:    1,			Description: "Test Item",			InvoiceID:   invoice.ID,		item := &entities.InvoiceItem{	if withItems {	require.NoError(t, err)	err := db.Create(invoice).Error	}		}			invoice.CancellationReason = "Test cancellation"			invoice.CancelledAt = testutils.NowPtr()		if status == entities.InvoiceStatusCancelled {		}			invoice.PaymentMethod = "bank_transfer"			invoice.PaymentDate = testutils.NowPtr()		if status == entities.InvoiceStatusPaid {		}			invoice.EmailSentAt = testutils.NowPtr()		if status == entities.InvoiceStatusSent || status == entities.InvoiceStatusPaid {		}			invoice.FinalizedAt = testutils.NowPtr()		if status == entities.InvoiceStatusFinalized || status == entities.InvoiceStatusSent || status == entities.InvoiceStatusPaid {		invoice.InvoiceNumber = testutils.GenerateTestInvoiceNumber(time.Now().Year(), int(tenantID))	if status != entities.InvoiceStatusDraft {	}		UpdatedAt:      time.Now().UTC(),		CreatedAt:      time.Now().UTC(),		VATTotal:       15.97,		Subtotal:       84.03,		Total:          100.00,		DueDate:        testutils.FutureTimePtr(30 * 24 * time.Hour),		InvoiceDate:    time.Now().UTC(),		Status:         status,		OrganizationID: 1,		UserID:         userID,		TenantID:       tenantID,	invoice := &entities.Invoice{	t.Helper()func createTestInvoice(t *testing.T, db *gorm.DB, status entities.InvoiceStatus, tenantID, userID uint, withItems bool) *entities.Invoice {// Helper function to create test invoice}	})		}			assert.NotEqual(t, invoice2.ID, inv.ID)		for _, inv := range tenant1Invoices {		// Tenant 1 should NOT see tenant 2's invoice				assert.Equal(t, invoice2.ID, tenant2Invoices[0].ID)		assert.Equal(t, invoice1.ID, tenant1Invoices[0].ID)		assert.Len(t, tenant2Invoices, 1)		assert.Len(t, tenant1Invoices, 1)		// Verify isolation		db.Where("tenant_id = ?", 2).Find(&tenant2Invoices)		var tenant2Invoices []entities.Invoice		// Tenant 2 queries		db.Where("tenant_id = ?", 1).Find(&tenant1Invoices)		var tenant1Invoices []entities.Invoice		// Tenant 1 queries		invoice2 := createTestInvoice(t, db, entities.InvoiceStatusSent, 2, 2, true)		invoice1 := createTestInvoice(t, db, entities.InvoiceStatusSent, 1, 1, true)		// Create invoices for different tenants	t.Run("tenant cannot access other tenant's invoices", func(t *testing.T) {	testutils.MigrateTestDB(t, db, &entities.Invoice{}, &entities.InvoiceItem{})	defer testutils.CleanupTestDB(db)	db := testutils.SetupTestDB(t)func TestGoBD_TenantIsolation(t *testing.T) {// GoBD Requirement: Zugriffskontrolle (Access Control)// TestGoBD_TenantIsolation tests multi-tenant data isolation}	})		t.Skip("Requires transaction rollback testing")				// or the next invoice should not skip a number		// If finalization fails, the invoice number should be returned to pool		// This tests the rollback scenario	t.Run("failed finalization does not create gap", func(t *testing.T) {	})		}			assert.NotEqual(t, invoices[i].InvoiceNumber, invoices[i+1].InvoiceNumber)			// All invoice numbers should be unique						assert.NotEmpty(t, invoices[i+1].InvoiceNumber)			assert.NotEmpty(t, invoices[i].InvoiceNumber)			// Simple check: each invoice has a number		for i := 0; i < len(invoices)-1; i++ {		// This assumes sequential format like "INV-1", "INV-2", etc.		// Extract sequence numbers and check for gaps		}			invoices = append(invoices, finalized)			require.NoError(t, err)			finalized, err := service.FinalizeInvoice(ctx, invoice.TenantID, invoice.ID, invoice.UserID)			service := services.NewInvoiceService(db)			invoice := createTestInvoice(t, db, entities.InvoiceStatusDraft, 1, 1, true)		for i := 0; i < count; i++ {		var invoices []*entities.Invoice		const count = 10		// Generate 10 invoices	t.Run("no gaps in invoice number sequence", func(t *testing.T) {	ctx := context.Background()	testutils.MigrateTestDB(t, db, &entities.Invoice{}, &entities.InvoiceItem{})	defer testutils.CleanupTestDB(db)	db := testutils.SetupTestDB(t)func TestGoBD_InvoiceNumberCompleteness(t *testing.T) {// GoBD Requirement: Vollständigkeit (Completeness)// TestGoBD_InvoiceNumberCompleteness tests that there are no gaps in invoice sequences}	})		assert.Equal(t, invoice.ID, foundItem.InvoiceID)		assert.NotNil(t, foundItem.Invoice)		require.NoError(t, err)		err := db.Preload("Invoice").First(&foundItem, item.ID).Error		var foundItem entities.InvoiceItem		// Verify foreign key relationship		db.Create(item)		}			Amount:      100.00,			UnitPrice:   100.00,			Quantity:    1,			Description: "Test Item",			InvoiceID:   invoice.ID,		item := &entities.InvoiceItem{		// Create item				invoice := createTestInvoice(t, db, entities.InvoiceStatusDraft, 1, 1, true)	t.Run("no orphaned invoice items", func(t *testing.T) {	})		}			testutils.AssertFloatEqual(t, tc.expected, vat, 0.01) // 1 cent tolerance			vat := tc.netAmount * (tc.vatRate / 100.0)		for _, tc := range testCases {		}			{99.99, 19.0, 19.00}, // Rounding			{100.00, 7.0, 7.00},			{100.00, 19.0, 19.00},		}{			expected  float64			vatRate   float64			netAmount float64		testCases := []struct {		// Test VAT calculation with different rates	t.Run("VAT calculations are correct", func(t *testing.T) {	})		testutils.AssertDecimalEqual(t, 208.85, total)		testutils.AssertDecimalEqual(t, 33.35, vat) // Allow 1 cent rounding difference		testutils.AssertDecimalEqual(t, 175.50, subtotal)		// Verify calculations		total := subtotal + vat		vat := subtotal * 0.19		}			subtotal += item.Amount		for _, item := range items {		subtotal := 0.0		db.Where("invoice_id = ?", invoice.ID).Find(&items)		var items []entities.InvoiceItem		// Recalculate totals		db.Create(item2)		db.Create(item1)		}			TaxRate:     19.0,			VATRate:     19.0,			Amount:      75.50,			UnitPrice:   75.50,			Quantity:    1,			Description: "Item 2",			InvoiceID:   invoice.ID,		item2 := &entities.InvoiceItem{		}			TaxRate:     19.0,			VATRate:     19.0,			Amount:      100.00,			UnitPrice:   50.00,			Quantity:    2,			Description: "Item 1",			InvoiceID:   invoice.ID,		item1 := &entities.InvoiceItem{		// Add items				invoice := createTestInvoice(t, db, entities.InvoiceStatusDraft, 1, 1, true)	t.Run("invoice total matches sum of line items", func(t *testing.T) {	testutils.MigrateTestDB(t, db, &entities.Invoice{}, &entities.InvoiceItem{})	defer testutils.CleanupTestDB(db)	db := testutils.SetupTestDB(t)func TestGoBD_DataIntegrity(t *testing.T) {// GoBD Requirement: Datenintegrität (Data Integrity)// TestGoBD_DataIntegrity tests calculation accuracy and data consistency}	})		testutils.AssertTimeBefore(t, *sent.EmailSentAt, *paid.PaymentDate)		testutils.AssertTimeBefore(t, *finalized.FinalizedAt, *sent.EmailSentAt)		testutils.AssertTimeBefore(t, invoice.CreatedAt, *finalized.FinalizedAt)		// Verify chronological order		require.NoError(t, err)		paid, err := service.MarkAsPaidWithAmount(ctx, invoice.TenantID, invoice.ID, paymentDate, "bank_transfer")		paymentDate := time.Now().UTC()		// Pay		require.NoError(t, err)		sent, err := service.MarkAsSent(ctx, invoice.TenantID, invoice.ID)		// Send		require.NoError(t, err)		finalized, err := service.FinalizeInvoice(ctx, invoice.TenantID, invoice.ID, invoice.UserID)		// Finalize				invoice := createTestInvoice(t, db, entities.InvoiceStatusDraft, 1, 1, true)	t.Run("chronological order maintained", func(t *testing.T) {	})		assert.True(t, finalized.FinalizedAt.Before(afterFinalize) || finalized.FinalizedAt.Equal(afterFinalize))		assert.True(t, finalized.FinalizedAt.After(beforeFinalize) || finalized.FinalizedAt.Equal(beforeFinalize))		require.NotNil(t, finalized.FinalizedAt)		afterFinalize := time.Now().UTC()		require.NoError(t, err)		finalized, err := service.FinalizeInvoice(ctx, invoice.TenantID, invoice.ID, invoice.UserID)		beforeFinalize := time.Now().UTC()				invoice := createTestInvoice(t, db, entities.InvoiceStatusDraft, 1, 1, true)	t.Run("finalized_at timestamp matches finalization time", func(t *testing.T) {	})		assert.Equal(t, "UTC", invoice.UpdatedAt.Location().String())		assert.Equal(t, "UTC", invoice.CreatedAt.Location().String())		// All timestamps should be in UTC				invoice := createTestInvoice(t, db, entities.InvoiceStatusDraft, 1, 1, true)	t.Run("timestamps use UTC", func(t *testing.T) {	service := services.NewInvoiceService(db)	ctx := context.Background()	testutils.MigrateTestDB(t, db, &entities.Invoice{}, &entities.InvoiceItem{})	defer testutils.CleanupTestDB(db)	db := testutils.SetupTestDB(t)func TestGoBD_TimestampIntegrity(t *testing.T) {// GoBD Requirement: Zeitstempel (Timestamp Integrity)// TestGoBD_TimestampIntegrity tests timestamp accuracy and consistency}	})		t.Skip("Requires document storage module integration")				// Later retrieval should verify hash matches		// PDF hash should be calculated and stored	t.Run("document hash stored for integrity verification", func(t *testing.T) {	})		t.Skip("Requires document storage module integration")				// Deletion attempts should fail with clear error message		// Documents should be marked as "under retention" for 10 years		// This would test document storage module	t.Run("invoice PDF cannot be deleted within retention period", func(t *testing.T) {func TestGoBD_DocumentRetention(t *testing.T) {// GoBD Requirement: Aufbewahrungspflicht (Document Retention)// TestGoBD_DocumentRetention tests 10-year document retention requirement}	})		assert.Equal(t, originalNumber, cancelled.InvoiceNumber)		require.NoError(t, err)		cancelled, err := service.CancelInvoice(ctx, invoice.TenantID, invoice.ID, "Test")		originalNumber := invoice.InvoiceNumber		invoice := createTestInvoice(t, db, entities.InvoiceStatusSent, 1, 1, true)	t.Run("cancellation preserves original invoice number", func(t *testing.T) {	})		assert.Contains(t, err.Error(), "cannot cancel paid")		assert.Error(t, err, "Should not allow cancelling paid invoice")		_, err := service.CancelInvoice(ctx, invoice.TenantID, invoice.ID, "Cancel paid")				invoice := createTestInvoice(t, db, entities.InvoiceStatusPaid, 1, 1, true)	t.Run("cannot cancel paid invoice without special workflow", func(t *testing.T) {	})		assert.Contains(t, err.Error(), "already cancelled")		assert.Error(t, err, "Should not allow cancelling already cancelled invoice")		_, err := service.CancelInvoice(ctx, invoice.TenantID, invoice.ID, "Second cancellation")		// Attempt second cancellation				invoice := createTestInvoice(t, db, entities.InvoiceStatusCancelled, 1, 1, true)		// Create cancelled invoice	t.Run("cannot cancel already cancelled invoice", func(t *testing.T) {	})		assert.Equal(t, invoice.InvoiceNumber, reloaded.InvoiceNumber, "Invoice number must be preserved")		assert.NotNil(t, reloaded.CancelledAt)		assert.Equal(t, reason, reloaded.CancellationReason)		assert.Equal(t, entities.InvoiceStatusCancelled, reloaded.Status)		// Verify cancellation metadata		require.NoError(t, err, "Cancelled invoice must remain in database")		err = db.First(&reloaded, invoice.ID).Error		var reloaded entities.Invoice		// Verify invoice still exists		require.NoError(t, err)		cancelled, err := service.CancelInvoice(ctx, invoice.TenantID, invoice.ID, reason)		reason := "Customer requested cancellation"		// Cancel invoice				invoice := createTestInvoice(t, db, entities.InvoiceStatusSent, 1, 1, true)		// Create and finalize invoice	t.Run("cancelled invoice remains in database", func(t *testing.T) {	service := services.NewInvoiceService(db)	ctx := context.Background()	testutils.MigrateTestDB(t, db, &entities.Invoice{}, &entities.InvoiceItem{})	defer testutils.CleanupTestDB(db)	db := testutils.SetupTestDB(t)func TestGoBD_Cancellation(t *testing.T) {// GoBD Requirement: Stornierung (Proper Cancellation)// TestGoBD_Cancellation tests proper invoice cancellation workflow}	})		t.Skip("Requires audit module integration")				// Audit entries should include: UserID, Timestamp, OldValue, NewValue		// Each step should create audit entries				// 4. Mark paid (should log: payment details, status change)		// 3. Send (should log: email sent, status change)		// 2. Finalize (should log: number generation, status change)		// 1. Create draft	t.Run("invoice lifecycle creates audit trail", func(t *testing.T) {		// For now, we test that critical operations are logged	// This test would require integration with audit module		defer testutils.CleanupTestDB(db)	db := testutils.SetupTestDB(t)func TestGoBD_AuditTrail(t *testing.T) {// GoBD Requirement: Nachvollziehbarkeit (Traceability)// TestGoBD_AuditTrail tests complete audit trail for invoice lifecycle}	}		})			}				}						"Paid invoice status must not be rolled back")					assert.Equal(t, originalStatus, reloaded.Status,				if tt.shouldFail {								db.First(&reloaded, invoice.ID)				var reloaded entities.Invoice								err := db.Save(&invoice).Error				invoice.Status = entities.InvoiceStatusDraft			case "status":				}						"Sent invoice total must not be modifiable")					assert.Equal(t, originalTotal, reloaded.Total,				if tt.shouldFail {								db.First(&reloaded, invoice.ID)				var reloaded entities.Invoice								err := db.Save(&invoice).Error				invoice.Total = 999.99			case "total":				}						"Finalized invoice number must not be modifiable")					assert.Equal(t, originalNumber, reloaded.InvoiceNumber, 					// Should still have original number				if tt.shouldFail {								db.First(&reloaded, invoice.ID)				var reloaded entities.Invoice				// Re-fetch to verify								err := db.Save(&invoice).Error				invoice.InvoiceNumber = "MODIFIED-001"			case "invoice_number":			switch tt.modification {			// Attempt modification			originalStatus := invoice.Status			originalTotal := invoice.Total			originalNumber := invoice.InvoiceNumber			// Store original values						invoice := createTestInvoice(t, db, tt.status, 1, 1, true)			// Create invoice with test status		t.Run(tt.name, func(t *testing.T) {	for _, tt := range tests {	}		},			shouldFail:   false,			modification: "customer_name",			status:       entities.InvoiceStatusDraft,			name:         "can modify draft invoice",		{		},			shouldFail:   true,			modification: "status",			status:       entities.InvoiceStatusPaid,			name:         "cannot modify paid invoice status back to draft",		{		},			shouldFail:   true,			modification: "total",			status:       entities.InvoiceStatusSent,			name:         "cannot modify sent invoice total",		{		},			shouldFail:   true,			modification: "invoice_number",			status:       entities.InvoiceStatusFinalized,			name:         "cannot modify finalized invoice number",		{	}{		shouldFail     bool		modification   string		status         entities.InvoiceStatus		name           string	tests := []struct {	service := services.NewInvoiceService(db)	ctx := context.Background()	)		&entities.InvoiceItem{},		&entities.Invoice{},	testutils.MigrateTestDB(t, db, 	// Migrate all required entities		defer testutils.CleanupTestDB(db)	db := testutils.SetupTestDB(t)func TestGoBD_Immutability(t *testing.T) {// GoBD Requirement: Unveränderbarkeit (Immutability)