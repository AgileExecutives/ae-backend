package handlers_test

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/suite"
	"gorm.io/driver/sqlite"
	"gorm.io/gorm"

	// Settings system imports
	"github.com/ae-base-server/pkg/settings/entities"
	"github.com/ae-base-server/pkg/settings/handlers"
	"github.com/ae-base-server/pkg/settings/manager"
	"github.com/ae-base-server/pkg/settings/registry"
	"github.com/ae-base-server/pkg/settings/repository"

	// Module settings providers
	companySettings "github.com/ae-base-server/modules/company/settings"
	invoiceSettings "github.com/ae-base-server/modules/invoice/settings"
	billingSettings "github.com/ae-base-server/modules/billing/settings"
)
































































































































































































































































































































































































































































































































































































































































































































































}	}		})			assert.NotEmpty(t, tc.expected)			assert.NotNil(t, tc.data)			// This would test response formatting utilities if we extracted them		t.Run(tc.name, func(t *testing.T) {	for _, tc := range testCases {	}		},			},				"error":   "error message",				"success": false,			expected: map[string]interface{}{			data: "error message",			name: "ErrorResponse",		{		},			},				"data":    "test data",				"success": true,			expected: map[string]interface{}{			data: "test data",			name: "SuccessResponse",		{	}{		expected map[string]interface{}		data     interface{}		name     string	testCases := []struct {	// Test response formatting utilitiesfunc TestResponseFormatting(t *testing.T) {}	}		})			assert.NotZero(t, test.expectedCode)			assert.NotEmpty(t, test.requestBody)			// For now, we'll just verify the test structure			// This would test request validation logic if we extracted it		t.Run(test.name, func(t *testing.T) {	for _, test := range tests {	}		},			expectedCode: http.StatusBadRequest,			requestBody:  `{"domain":"company","key":"test_key","value":"test_value","type":"invalid"}`,			name:         "InvalidType",		{		},			expectedCode: http.StatusBadRequest,			requestBody:  `{"domain":"company","key":"test_key","type":"string"}`,			name:         "MissingValue",		{		},			expectedCode: http.StatusBadRequest,			requestBody:  `{"domain":"company","value":"test_value","type":"string"}`,			name:         "MissingKey",		{		},			expectedCode: http.StatusBadRequest,			requestBody:  `{"key":"test_key","value":"test_value","type":"string"}`,			name:         "MissingDomain",		{		},			expectedCode: http.StatusBadRequest,			requestBody:  `{"domain":"company","key":"test_key","value":}`,			name:         "InvalidJSON",		{		},			expectedCode: http.StatusOK, // Would be created in real handler			requestBody:  `{"domain":"company","key":"test_key","value":"test_value","type":"string"}`,			name:         "ValidRequest",		{	}{		expectedCode int		requestBody  string		name         string	tests := []struct {	// Test various request validation scenariosfunc TestRequestValidation(t *testing.T) {// Additional unit tests for handler utilities}	suite.Run(t, new(SettingsHandlerTestSuite))func TestSettingsHandlers(t *testing.T) {// Run the test suite}	suite.Equal(numRequests, concurrentKeyCount, "All concurrent settings should be stored")	}		}			concurrentKeyCount++		if len(key) > 14 && key[:14] == "concurrent_key" {	for key := range settings {	concurrentKeyCount := 0	// Count concurrent keys	suite.True(ok)	settings, ok := response["settings"].(map[string]interface{})	suite.NoError(err)	err := json.Unmarshal(w.Body.Bytes(), &response)	var response map[string]interface{}	suite.Equal(http.StatusOK, w.Code)	suite.router.ServeHTTP(w, req)	req, _ := http.NewRequest("GET", fmt.Sprintf("/api/v1/settings/organizations/%s/domains/company", organizationID), nil)	w := httptest.NewRecorder()	// Verify all settings were created	suite.Equal(numRequests, successCount, "All concurrent requests should succeed")	}		}			successCount++		if w.Code == http.StatusCreated {		w := <-responses	for i := 0; i < numRequests; i++ {	successCount := 0	// Collect and verify responses	}		}(i)			responses <- w			suite.router.ServeHTTP(w, req)			req.Header.Set("Content-Type", "application/json")			req, _ := http.NewRequest("POST", fmt.Sprintf("/api/v1/settings/organizations/%s", organizationID), bytes.NewBuffer(body))			w := httptest.NewRecorder()			body, _ := json.Marshal(settingData)			}				"type":   "string",				"value":  fmt.Sprintf("concurrent_value_%d", requestID),				"key":    fmt.Sprintf("concurrent_key_%d", requestID),				"domain": "company",			settingData := map[string]interface{}{		go func(requestID int) {	for i := 0; i < numRequests; i++ {	// Launch concurrent requests	responses := make(chan *httptest.ResponseRecorder, numRequests)	// Channel to collect responses	const numRequests = 10	organizationID := "test-org-concurrent"func (suite *SettingsHandlerTestSuite) TestConcurrentRequests() {// TestConcurrentRequests tests concurrent API requests}	suite.Equal(http.StatusBadRequest, w.Code)	suite.router.ServeHTTP(w, req)	req.Header.Set("Content-Type", "application/json")	req, _ = http.NewRequest("POST", fmt.Sprintf("/api/v1/settings/organizations/%s", organizationID), bytes.NewBufferString("invalid json"))	w = httptest.NewRecorder()	// Test invalid JSON in request body	suite.Equal(http.StatusNotFound, w.Code)	suite.router.ServeHTTP(w, req)	req, _ = http.NewRequest("GET", fmt.Sprintf("/api/v1/settings/organizations/%s/domains/nonexistent", organizationID), nil)	w = httptest.NewRecorder()	// Test getting settings from nonexistent domain	suite.Equal(http.StatusBadRequest, w.Code)	suite.router.ServeHTTP(w, req)	req.Header.Set("Content-Type", "application/json")	req, _ := http.NewRequest("POST", fmt.Sprintf("/api/v1/settings/organizations/%s", organizationID), bytes.NewBuffer(body))	w := httptest.NewRecorder()	body, _ := json.Marshal(invalidDomainData)	}		"type":   "string",		"value":  "some_value",		"key":    "some_key",		"domain": "nonexistent",	invalidDomainData := map[string]interface{}{	// Test setting with invalid domain	organizationID := "test-org-errors"func (suite *SettingsHandlerTestSuite) TestErrorHandling() {// TestErrorHandling tests various error conditions}	suite.Equal("12345", address["postal_code"])	suite.Equal("Test City", address["city"])	suite.Equal("123 API Test St", address["street"])	suite.True(ok)	address, ok := settings["billing_address"].(map[string]interface{})	suite.True(ok)	settings, ok := response["settings"].(map[string]interface{})	suite.NoError(err)	err := json.Unmarshal(w.Body.Bytes(), &response)	var response map[string]interface{}	suite.Equal(http.StatusOK, w.Code)	suite.router.ServeHTTP(w, req)	req, _ = http.NewRequest("GET", fmt.Sprintf("/api/v1/settings/organizations/%s/domains/billing", organizationID), nil)	w = httptest.NewRecorder()	// Verify JSON setting was stored correctly	suite.Equal(http.StatusCreated, w.Code)	suite.router.ServeHTTP(w, req)	req.Header.Set("Content-Type", "application/json")	req, _ := http.NewRequest("POST", fmt.Sprintf("/api/v1/settings/organizations/%s", organizationID), bytes.NewBuffer(body))	w := httptest.NewRecorder()	body, _ := json.Marshal(jsonSetting)	}		"type": "json",		},			"country":     "US",			"postal_code": "12345",			"state":       "TS",			"city":        "Test City",			"street":      "123 API Test St",		"value": map[string]interface{}{		"key":    "billing_address",		"domain": "billing",	jsonSetting := map[string]interface{}{	// Test setting complex JSON data	organizationID := "test-org-json"func (suite *SettingsHandlerTestSuite) TestJSONSettings() {// TestJSONSettings tests complex JSON settings}	suite.NotEmpty(response["errors"])	suite.False(response["valid"].(bool))	suite.NoError(err)	err = json.Unmarshal(w.Body.Bytes(), &response)	suite.Equal(http.StatusBadRequest, w.Code)	suite.router.ServeHTTP(w, req)	req.Header.Set("Content-Type", "application/json")	req, _ = http.NewRequest("POST", fmt.Sprintf("/api/v1/settings/organizations/%s/validate", organizationID), bytes.NewBuffer(body))	w = httptest.NewRecorder()	body, _ = json.Marshal(invalidValidationData)	}		},			"company_name": 123, // Should be string, not int		"settings": map[string]interface{}{		"domain": "company",	invalidValidationData := map[string]interface{}{	// Test invalid settings	suite.True(response["valid"].(bool))	suite.NoError(err)	err := json.Unmarshal(w.Body.Bytes(), &response)	var response map[string]interface{}	suite.Equal(http.StatusOK, w.Code)	suite.router.ServeHTTP(w, req)	req.Header.Set("Content-Type", "application/json")	req, _ := http.NewRequest("POST", fmt.Sprintf("/api/v1/settings/organizations/%s/validate", organizationID), bytes.NewBuffer(body))	w := httptest.NewRecorder()	body, _ := json.Marshal(validationData)	}		},			"company_email": "valid@example.com",			"company_name":  "Valid Company",		"settings": map[string]interface{}{		"domain": "company",	validationData := map[string]interface{}{	// Test valid settings	organizationID := "test-org-validate"func (suite *SettingsHandlerTestSuite) TestValidateSettings() {// TestValidateSettings tests the settings validation endpoint}	suite.GreaterOrEqual(len(settings), 1)	suite.True(ok)	settings, ok := schema["settings"].([]interface{})	suite.Equal("company", schema["domain"])	suite.Equal("company", schema["module_name"])	suite.True(ok)	schema, ok := response["schema"].(map[string]interface{})	suite.NoError(err)	err = json.Unmarshal(w.Body.Bytes(), &response)	suite.Equal(http.StatusOK, w.Code)	suite.router.ServeHTTP(w, req)	req, _ = http.NewRequest("GET", fmt.Sprintf("/api/v1/settings/organizations/%s/schema/company", organizationID), nil)	w = httptest.NewRecorder()	// Test getting specific domain schema	suite.GreaterOrEqual(len(schemas), 3) // At least company, invoice, billing	suite.True(ok)	schemas, ok := response["schemas"].([]interface{})	suite.NoError(err)	err := json.Unmarshal(w.Body.Bytes(), &response)	var response map[string]interface{}	suite.Equal(http.StatusOK, w.Code)	suite.router.ServeHTTP(w, req)	req, _ := http.NewRequest("GET", fmt.Sprintf("/api/v1/settings/organizations/%s/schema", organizationID), nil)	w := httptest.NewRecorder()	// Test getting all schemas	organizationID := "test-org-schema"func (suite *SettingsHandlerTestSuite) TestSchemaOperations() {// TestSchemaOperations tests schema-related operations}	suite.Empty(settings, "Domain settings should be deleted")	suite.True(ok)	settings, ok = response["settings"].(map[string]interface{})	suite.NoError(err)	err = json.Unmarshal(w.Body.Bytes(), &response)	suite.Equal(http.StatusOK, w.Code)	suite.router.ServeHTTP(w, req)	req, _ = http.NewRequest("GET", fmt.Sprintf("/api/v1/settings/organizations/%s/domains/company", organizationID), nil)	w = httptest.NewRecorder()	// Verify domain settings are deleted	suite.Equal(http.StatusOK, w.Code)	suite.router.ServeHTTP(w, req)	req, _ = http.NewRequest("DELETE", fmt.Sprintf("/api/v1/settings/organizations/%s/domains/company", organizationID), nil)	w = httptest.NewRecorder()	// Test deleting domain settings	suite.Equal("https://domaintest.com", settings["company_website"])	suite.Equal("domain@example.com", settings["company_email"])	suite.Equal("Domain Test Company", settings["company_name"])	suite.True(ok)	settings, ok := response["settings"].(map[string]interface{})	suite.NoError(err)	err = json.Unmarshal(w.Body.Bytes(), &response)	suite.Equal(http.StatusOK, w.Code)	suite.router.ServeHTTP(w, req)	req, _ = http.NewRequest("GET", fmt.Sprintf("/api/v1/settings/organizations/%s/domains/company", organizationID), nil)	w = httptest.NewRecorder()	// Test getting specific domain settings	suite.Contains(domains, "company")	suite.True(ok)	domains, ok := response["domains"].([]interface{})	suite.NoError(err)	err := json.Unmarshal(w.Body.Bytes(), &response)	var response map[string]interface{}	suite.Equal(http.StatusOK, w.Code)	suite.router.ServeHTTP(w, req)	req, _ = http.NewRequest("GET", fmt.Sprintf("/api/v1/settings/organizations/%s/domains", organizationID), nil)	w = httptest.NewRecorder()	// Test getting domains	suite.Equal(http.StatusCreated, w.Code)	suite.router.ServeHTTP(w, req)	req.Header.Set("Content-Type", "application/json")	req, _ := http.NewRequest("POST", fmt.Sprintf("/api/v1/settings/organizations/%s/domains/company", organizationID), bytes.NewBuffer(body))	w := httptest.NewRecorder()	body, _ := json.Marshal(domainData)	}		},			"company_website": "https://domaintest.com",			"company_email":   "domain@example.com",			"company_name":    "Domain Test Company",		"settings": map[string]interface{}{	domainData := map[string]interface{}{	// Set some domain-specific settings	organizationID := "test-org-domain"func (suite *SettingsHandlerTestSuite) TestDomainOperations() {// TestDomainOperations tests domain-specific operations}	suite.Equal("BULK", invoiceSettings["invoice_prefix"])	suite.True(ok)	invoiceSettings, ok := settings["invoice"].(map[string]interface{})	suite.Equal("bulk@example.com", companySettings["company_email"])	suite.Equal("Bulk Test Company", companySettings["company_name"])	suite.True(ok)	companySettings, ok := settings["company"].(map[string]interface{})	suite.True(ok)	settings, ok := response["settings"].(map[string]interface{})	suite.NoError(err)	err := json.Unmarshal(w.Body.Bytes(), &response)	var response map[string]interface{}	suite.Equal(http.StatusOK, w.Code)	suite.router.ServeHTTP(w, req)	req, _ = http.NewRequest("GET", fmt.Sprintf("/api/v1/settings/organizations/%s", organizationID), nil)	w = httptest.NewRecorder()	// Verify bulk settings were created	suite.Equal(http.StatusCreated, w.Code)	suite.router.ServeHTTP(w, req)	req.Header.Set("Content-Type", "application/json")	req, _ := http.NewRequest("POST", fmt.Sprintf("/api/v1/settings/organizations/%s/bulk", organizationID), bytes.NewBuffer(body))	w := httptest.NewRecorder()	body, _ := json.Marshal(bulkData)	}		},			},				"type":   "string",				"value":  "BULK",				"key":    "invoice_prefix",				"domain": "invoice",			{			},				"type":   "string",				"value":  "bulk@example.com",				"key":    "company_email",				"domain": "company",			{			},				"type":   "string",				"value":  "Bulk Test Company",				"key":    "company_name",				"domain": "company",			{		"settings": []map[string]interface{}{	bulkData := map[string]interface{}{	// Test bulk set	organizationID := "test-org-bulk"func (suite *SettingsHandlerTestSuite) TestBulkOperations() {// TestBulkOperations tests bulk setting operations}	suite.False(exists, "Setting should be deleted")	_, exists := settings["company_phone"]	suite.True(ok)	settings, ok := response["settings"].(map[string]interface{})	suite.NoError(err)	err := json.Unmarshal(w.Body.Bytes(), &response)	var response map[string]interface{}	suite.Equal(http.StatusOK, w.Code)	suite.router.ServeHTTP(w, req)	req, _ = http.NewRequest("GET", fmt.Sprintf("/api/v1/settings/organizations/%s/domains/company", organizationID), nil)	w = httptest.NewRecorder()	// Verify it's deleted	suite.Equal(http.StatusOK, w.Code)	suite.router.ServeHTTP(w, req)	req, _ = http.NewRequest("DELETE", fmt.Sprintf("/api/v1/settings/organizations/%s/company/company_phone", organizationID), nil)	w = httptest.NewRecorder()	// Delete the setting	suite.Equal(http.StatusCreated, w.Code)	suite.router.ServeHTTP(w, req)	req.Header.Set("Content-Type", "application/json")	req, _ := http.NewRequest("POST", fmt.Sprintf("/api/v1/settings/organizations/%s", organizationID), bytes.NewBuffer(body))	w := httptest.NewRecorder()	body, _ := json.Marshal(settingData)	}		"type":   "string",		"value":  "+1-555-0123",		"key":    "company_phone",		"domain": "company",	settingData := map[string]interface{}{	// First, create a setting	organizationID := "test-org-3"func (suite *SettingsHandlerTestSuite) TestDeleteSetting() {// TestDeleteSetting tests deleting settings}	suite.Equal("new@example.com", settings["company_email"])	suite.True(ok)	settings, ok := response["settings"].(map[string]interface{})	suite.NoError(err)	err := json.Unmarshal(w.Body.Bytes(), &response)	var response map[string]interface{}	suite.Equal(http.StatusOK, w.Code)	suite.router.ServeHTTP(w, req)	req, _ = http.NewRequest("GET", fmt.Sprintf("/api/v1/settings/organizations/%s/domains/company", organizationID), nil)	w = httptest.NewRecorder()	// Verify the update	suite.Equal(http.StatusOK, w.Code)	suite.router.ServeHTTP(w, req)	req.Header.Set("Content-Type", "application/json")	req, _ = http.NewRequest("PUT", fmt.Sprintf("/api/v1/settings/organizations/%s/company/company_email", organizationID), bytes.NewBuffer(body))	w = httptest.NewRecorder()	body, _ = json.Marshal(updateData)	}		"type":  "string",		"value": "new@example.com",	updateData := map[string]interface{}{	// Now update it	suite.Equal(http.StatusCreated, w.Code)	suite.router.ServeHTTP(w, req)	req.Header.Set("Content-Type", "application/json")	req, _ := http.NewRequest("POST", fmt.Sprintf("/api/v1/settings/organizations/%s", organizationID), bytes.NewBuffer(body))	w := httptest.NewRecorder()	body, _ := json.Marshal(settingData)	}		"type":   "string",		"value":  "old@example.com",		"key":    "company_email",		"domain": "company",	settingData := map[string]interface{}{	// First, create a setting	organizationID := "test-org-2"func (suite *SettingsHandlerTestSuite) TestUpdateSetting() {// TestUpdateSetting tests updating existing settings}	suite.Equal("Test Company API", companySettings["company_name"])	suite.True(ok)	companySettings, ok := settings["company"].(map[string]interface{})	suite.True(ok)	settings, ok := response["settings"].(map[string]interface{})	suite.NoError(err)	err := json.Unmarshal(w.Body.Bytes(), &response)	var response map[string]interface{}	suite.Equal(http.StatusOK, w.Code)	suite.router.ServeHTTP(w, req)	req, _ = http.NewRequest("GET", fmt.Sprintf("/api/v1/settings/organizations/%s", organizationID), nil)	w = httptest.NewRecorder()	// Test getting settings	suite.Equal(http.StatusCreated, w.Code)	suite.router.ServeHTTP(w, req)	req.Header.Set("Content-Type", "application/json")	req, _ := http.NewRequest("POST", fmt.Sprintf("/api/v1/settings/organizations/%s", organizationID), bytes.NewBuffer(body))	w := httptest.NewRecorder()	body, _ := json.Marshal(settingData)	}		"type":   "string",		"value":  "Test Company API",		"key":    "company_name",		"domain": "company",	settingData := map[string]interface{}{	// Test setting a value	organizationID := "test-org-1"func (suite *SettingsHandlerTestSuite) TestSetAndGetSetting() {// TestSetAndGetSetting tests setting and retrieving individual settings}	suite.GreaterOrEqual(len(modules), 3) // At least company, invoice, billing	suite.True(ok)	modules, ok := response["modules"].([]interface{})	suite.NoError(err)	err := json.Unmarshal(w.Body.Bytes(), &response)	var response map[string]interface{}	suite.Equal(http.StatusOK, w.Code)	suite.router.ServeHTTP(w, req)	req, _ := http.NewRequest("GET", "/api/v1/settings/modules", nil)	w := httptest.NewRecorder()func (suite *SettingsHandlerTestSuite) TestGetRegisteredModules() {// TestGetRegisteredModules tests the modules endpoint}	suite.Equal("ok", response["status"])	suite.NoError(err)	err := json.Unmarshal(w.Body.Bytes(), &response)	var response map[string]interface{}	suite.Equal(http.StatusOK, w.Code)	suite.router.ServeHTTP(w, req)	req, _ := http.NewRequest("GET", "/api/v1/settings/health", nil)	w := httptest.NewRecorder()func (suite *SettingsHandlerTestSuite) TestHealthCheck() {// TestHealthCheck tests the health check endpoint}	}		settingsGroup.GET("/version", suite.handler.GetVersion)		settingsGroup.GET("/modules", suite.handler.GetRegisteredModules)		settingsGroup.GET("/health", suite.handler.HealthCheck)		// Global settings routes (not organization-specific)		}			orgGroup.POST("/import", suite.handler.ImportSettings)			orgGroup.GET("/export", suite.handler.ExportSettings)			// Import/Export			orgGroup.POST("/validate", suite.handler.ValidateSettings)			orgGroup.GET("/schema/:domain", suite.handler.GetDomainSchema)			orgGroup.GET("/schema", suite.handler.GetSettingsSchema)			// Schema and validation			orgGroup.DELETE("/domains/:domain", suite.handler.DeleteDomainSettings)			orgGroup.POST("/domains/:domain", suite.handler.SetDomainSettings)			orgGroup.GET("/domains/:domain", suite.handler.GetDomainSettings)			orgGroup.GET("/domains", suite.handler.GetDomains)			// Domain-specific operations			orgGroup.DELETE("/bulk", suite.handler.BulkDeleteSettings)			orgGroup.PUT("/bulk", suite.handler.BulkUpdateSettings)			orgGroup.POST("/bulk", suite.handler.BulkSetSettings)			// Bulk operations			orgGroup.DELETE("/:domain/:key", suite.handler.DeleteSetting)			orgGroup.PUT("/:domain/:key", suite.handler.UpdateSetting)			orgGroup.POST("", suite.handler.SetSetting)			orgGroup.GET("", suite.handler.GetSettings)			// Basic CRUD operations		{		orgGroup := settingsGroup.Group("/organizations/:organization_id")		// Organization settings routes	{	settingsGroup := suite.router.Group("/api/v1/settings")	// Settings API routes	suite.router = gin.New()func (suite *SettingsHandlerTestSuite) setupRouter() {// setupRouter configures the test router with settings routes}	}		suite.Require().NoError(err)		err := registry.RegisterProvider(module)	for _, module := range modules {	}		billingSettings.NewBillingSettingsProvider(),		invoiceSettings.NewInvoiceSettingsProvider(),		companySettings.NewCompanySettingsProvider(),	modules := []interface{}{func (suite *SettingsHandlerTestSuite) registerTestModules(registry *registry.SettingsRegistry) {// registerTestModules registers modules for testing}	}		sqlDB.Close()		sqlDB, _ := suite.db.DB()	if suite.db != nil {func (suite *SettingsHandlerTestSuite) TearDownSuite() {// TearDownSuite runs once after all tests in the suite}	suite.setupRouter()	// Setup router	suite.Require().NoError(err)	err = suite.manager.Initialize()	// Initialize the manager	suite.registerTestModules(registry)	// Register test modules	suite.handler = handlers.NewSettingsHandler(suite.manager)	suite.manager = manager.NewSettingsManager(repo, registry)	registry := registry.NewSettingsRegistry()	repo := repository.NewSettingsRepository(db)	suite.db = db	// Initialize components	suite.Require().NoError(err)	err = repository.AutoMigrateSettingsTables(db)	// Auto-migrate tables	suite.Require().NoError(err)	db, err := gorm.Open(sqlite.Open(":memory:"), &gorm.Config{})	// Initialize in-memory SQLite database for testing	gin.SetMode(gin.TestMode)	// Set Gin to test modefunc (suite *SettingsHandlerTestSuite) SetupSuite() {// SetupSuite runs once before all tests in the suite}	router  *gin.Engine	handler *handlers.SettingsHandler	manager *manager.SettingsManager	db      *gorm.DB	suite.Suitetype SettingsHandlerTestSuite struct {// SettingsHandlerTestSuite provides a test suite for the settings HTTP handlers)	billingSettings "github.com/ae-base-server/modules/billing/settings"	invoiceSettings "github.com/ae-base-server/modules/invoice/settings"	companySettings "github.com/ae-base-server/modules/company/settings"	// Module settings providers