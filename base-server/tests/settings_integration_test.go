package settings_test

import (
	"fmt"
	"testing"
	"time"
	"gorm.io/driver/sqlite"
	"gorm.io/gorm"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/suite"

	// Settings system imports
	"github.com/ae-base-server/pkg/settings/entities"
	"github.com/ae-base-server/pkg/settings/repository"
	"github.com/ae-base-server/pkg/settings/registry"
	"github.com/ae-base-server/pkg/settings/manager"
	"github.com/ae-base-server/pkg/settings/accessor"

	// Module settings providers
























































































































































































































































































































































































































































































































































































































}	}		})			}				assert.Equal(t, test.expected, result, "Casted value doesn't match expected")				assert.NoError(t, err, "Expected casting to succeed")			} else {				assert.Error(t, err, "Expected casting to fail")			if test.shouldError {						result, err := entities.CastToType(test.input, test.targetType)		t.Run(test.name, func(t *testing.T) {	for _, test := range tests {	}		{"IntToFloat", 42, entities.SettingTypeFloat, 42.0, false},		{"StringToFloat", "3.14", entities.SettingTypeFloat, 3.14, false},		{"BoolToBool", false, entities.SettingTypeBool, false, false},		{"StringToBool", "true", entities.SettingTypeBool, true, false},		{"InvalidStringToInt", "not a number", entities.SettingTypeInt, nil, true},		{"IntToInt", 42, entities.SettingTypeInt, int64(42), false},		{"StringToInt", "42", entities.SettingTypeInt, int64(42), false},		{"IntToString", 42, entities.SettingTypeString, "42", false},		{"StringToString", "hello", entities.SettingTypeString, "hello", false},	}{		shouldError bool		expected    interface{}		targetType  entities.SettingType		input       interface{}		name        string	tests := []struct {	// Test type casting functionalityfunc TestSettingTypeCasting(t *testing.T) {}	}		})			}				assert.Error(t, err, "Expected invalid setting to fail validation")			} else {				assert.NoError(t, err, "Expected valid setting to pass validation")			if test.valid {			err := entities.ValidateSetting(setting)			}				Value: test.value,				Type:  test.settingType,			setting := &entities.Setting{		t.Run(test.name, func(t *testing.T) {	for _, test := range tests {	}		{"InvalidJSON", entities.SettingTypeJSON, make(chan int), false}, // channels can't be JSON encoded		{"ValidJSON", entities.SettingTypeJSON, map[string]interface{}{"key": "value"}, true},		{"InvalidFloat", entities.SettingTypeFloat, "not a float", false},		{"ValidFloatFromString", entities.SettingTypeFloat, "3.14", true},		{"ValidFloat", entities.SettingTypeFloat, 3.14, true},		{"InvalidBool", entities.SettingTypeBool, "maybe", false},		{"ValidBoolFromString", entities.SettingTypeBool, "true", true},		{"ValidBool", entities.SettingTypeBool, true, true},		{"InvalidInt", entities.SettingTypeInt, "not a number", false},		{"ValidIntFromString", entities.SettingTypeInt, "42", true},		{"ValidInt", entities.SettingTypeInt, 42, true},		{"InvalidString", entities.SettingTypeString, 123, false},		{"ValidString", entities.SettingTypeString, "test", true},	}{		valid    bool		value    interface{}		settingType entities.SettingType		name     string	tests := []struct {	// Test setting type validationfunc TestSettingValidation(t *testing.T) {// Additional unit tests for specific components}	suite.Run(t, new(SettingsTestSuite))func TestSettingsSystem(t *testing.T) {// Run the test suite}	})		}			}				suite.Equal(v, actual)				suite.NoError(err)				err := accessor.GetJSON(key, &actual)				var actual map[string]interface{}			case map[string]interface{}:				suite.Equal(v, actual)				suite.NoError(err)				actual, err := accessor.GetBool(key)			case bool:				suite.Equal(int64(v), actual)				suite.NoError(err)				actual, err := accessor.GetInt(key)			case int:				suite.Equal(v, actual)				suite.NoError(err)				actual, err := accessor.GetString(key)			case string:			switch v := expected.(type) {		for key, expected := range bulkSettings {		// Verify bulk settings		}			suite.NoError(err)			err := accessor.Set(key, value)		for key, value := range bulkSettings {		// Bulk set		}			},				"count":  10,				"nested": "value",			"bulk_setting_4": map[string]interface{}{			"bulk_setting_3": true,			"bulk_setting_2": 42,			"bulk_setting_1": "value1",		bulkSettings := map[string]interface{}{	suite.Run("BulkOperations", func() {	// Scenario: Bulk operations	})		suite.Equal("IT", prefix)		suite.NoError(err)		prefix, err := accessor.GetString("invoice_prefix")		suite.Equal("Business City", address["city"])		suite.NoError(err)		err = accessor.GetJSON("billing_address", &address)		var address map[string]interface{}		suite.Equal("Integration Test Company", name)		suite.NoError(err)		name, err := accessor.GetString("company_name")		// Verify all settings were stored correctly		suite.NoError(err)		err = accessor.Set("invoice_auto_number", true)		suite.NoError(err)		err = accessor.Set("invoice_prefix", "IT")		// Set invoice preferences		suite.NoError(err)		err := accessor.Set("billing_address", billingAddress)		}			"country":     "US",			"postal_code": "54321",			"state":       "BC",			"city":        "Business City",			"street":      "456 Business Ave",		billingAddress := map[string]interface{}{		// Set billing information		}			suite.NoError(err)			err := accessor.Set(key, value)		for key, value := range companySettings {		}			"company_website": "https://integrationtest.com",			"company_phone":   "+1-555-0123",			"company_email":   "admin@integrationtest.com",			"company_name":    "Integration Test Company",		companySettings := map[string]interface{}{		// Set company information	suite.Run("NewOrganizationSetup", func() {	// Scenario: Setting up a new organization	suite.NoError(err)	accessor, err := suite.manager.GetAccessor(tenantID, organizationID)	organizationID := "integration-test-org"	tenantID := int64(1)func (suite *SettingsTestSuite) TestSettingsIntegration() {// TestSettingsIntegration tests end-to-end integration scenarios}	suite.True(readTime < writeTime/2, "Cached reads should be much faster than writes")	// Reads should be significantly faster than writes due to caching		numOperations, readTime, float64(numOperations)/readTime.Seconds())	suite.T().Logf("Read performance: %d ops in %v (%.2f ops/sec)", 		numOperations, writeTime, float64(numOperations)/writeTime.Seconds())	suite.T().Logf("Write performance: %d ops in %v (%.2f ops/sec)", 	readTime := time.Since(start)	}		suite.NoError(err)		_, err := accessor.GetString(key)		key := fmt.Sprintf("perf_key_%d", i)	for i := 0; i < numOperations; i++ {	start = time.Now()	// Test read performance (should be faster due to caching)	writeTime := time.Since(start)	}		suite.NoError(err)		err := accessor.Set(key, value)		value := fmt.Sprintf("perf_value_%d", i)		key := fmt.Sprintf("perf_key_%d", i)	for i := 0; i < numOperations; i++ {	start := time.Now()	// Test write performance	const numOperations = 1000	// Benchmark setting and getting values	suite.NoError(err)	accessor, err := suite.manager.GetAccessor(tenantID, organizationID)	organizationID := "performance-test-org"	tenantID := int64(1)func (suite *SettingsTestSuite) TestPerformance() {// TestPerformance tests performance characteristics}	}		suite.NoError(err, "Concurrent operation failed")		err := <-errors	for i := 0; i < numGoroutines; i++ {	// Wait for all goroutines to complete and check for errors	}		}(i)			errors <- nil			}				}					return					errors <- fmt.Errorf("expected %s, got %s", value, retrieved)				} else if retrieved != value {					return					errors <- err				if retrieved, err := accessor.GetString(key); err != nil {				// Get value				}					return					errors <- err				if err := accessor.Set(key, value); err != nil {				// Set value				value := fmt.Sprintf("test_value_%d_%d", goroutineID, j)				key := fmt.Sprintf("test_key_%d_%d", goroutineID, j)			for j := 0; j < numOperations; j++ {			}				return				errors <- err			if err != nil {			accessor, err := suite.manager.GetAccessor(tenantID, organizationID)		go func(goroutineID int) {	for i := 0; i < numGoroutines; i++ {	// Launch concurrent goroutines		errors := make(chan error, numGoroutines*numOperations)	const numOperations = 100	const numGoroutines = 10	// Test concurrent reads and writes	organizationID := "concurrency-test-org"	tenantID := int64(1)func (suite *SettingsTestSuite) TestConcurrency() {// TestConcurrency tests concurrent access to settings}	})		suite.Equal("Test City", retrievedAddress["city"])		suite.Equal("123 Main St", retrievedAddress["street"])		suite.NoError(err)		err = accessor.GetJSON("billing_address", &retrievedAddress)		var retrievedAddress map[string]interface{}		suite.NoError(err)		err := accessor.Set("billing_address", address)		}			"country":     "US",			"postal_code": "12345",			"city":        "Test City",			"street":      "123 Main St",		address := map[string]interface{}{	suite.Run("BillingSettings", func() {	// Test Billing settings	})		suite.True(autoNumber)		suite.NoError(err)		autoNumber, err := accessor.GetBool("invoice_auto_number")		suite.Equal("INV", prefix)		suite.NoError(err)		prefix, err := accessor.GetString("invoice_prefix")		suite.NoError(err)		err = accessor.Set("invoice_auto_number", true)		suite.NoError(err)		err := accessor.Set("invoice_prefix", "INV")	suite.Run("InvoiceSettings", func() {	// Test Invoice settings	})		suite.Equal("info@testcompany.com", email)		suite.NoError(err)		email, err := accessor.GetString("company_email")		suite.Equal("Test Company Ltd", name)		suite.NoError(err)		name, err := accessor.GetString("company_name")		suite.NoError(err)		err = accessor.Set("company_email", "info@testcompany.com")		suite.NoError(err)		err := accessor.Set("company_name", "Test Company Ltd")	suite.Run("CompanySettings", func() {	// Test Company settings	suite.NoError(err)	accessor, err := suite.manager.GetAccessor(tenantID, organizationID)	organizationID := "module-test-org"	tenantID := int64(1)func (suite *SettingsTestSuite) TestModuleProviders() {// TestModuleProviders tests the specific module providers}	suite.Error(err)	err = suite.manager.ValidateSettings(entities.DomainCompany, invalidSettings)	}		"company_name": 123, // Should be string, not int	invalidSettings := map[string]interface{}{	// Test validation failure	suite.NoError(err)	err = suite.manager.ValidateSettings(entities.DomainCompany, settings)	}		"company_email": "valid@example.com",		"company_name":  "Valid Company",	settings := map[string]interface{}{	// Test ValidateSettings	suite.NotEmpty(schemas)	schemas := suite.manager.GetSchemas()	// Test GetSchemas	suite.Equal(accessor, accessor2) // Should be the same instance due to caching	suite.NoError(err)	accessor2, err := suite.manager.GetAccessor(tenantID, organizationID)	// Test that the same accessor is returned for the same tenant/org	suite.NotNil(accessor)	suite.NoError(err)	accessor, err := suite.manager.GetAccessor(tenantID, organizationID)	// Test GetAccessor	organizationID := "manager-test-org"	tenantID := int64(1)func (suite *SettingsTestSuite) TestSettingsManager() {// TestSettingsManager tests the manager functionality}	suite.Equal(true, retrieved["active"])	suite.Equal(float64(10), retrieved["count"]) // JSON numbers become float64	suite.Equal("Test", retrieved["name"])	suite.NoError(err)	err = accessor.GetJSON("test_json", &retrieved)	var retrieved map[string]interface{}	suite.NoError(err)	err = accessor.Set("test_json", jsonData)	}		"active": true,		"count": 10,		"name":  "Test",	jsonData := map[string]interface{}{	// Test JSON setting and getting	}		suite.Equal(test.expected, result, "Value mismatch for %s", test.key)		suite.NoError(err, "Failed to get %s", test.key)		result, err := test.getter(test.key)		// Get the value		suite.NoError(err, "Failed to set %s", test.key)		err := accessor.Set(test.key, test.value)		// Set the value	for _, test := range tests {	}		},			expected: 3.14,			},				return accessor.GetFloat(k)			getter: func(k string) (interface{}, error) {			value: 3.14,			key:   "test_float",		{		},			expected: true,			},				return accessor.GetBool(k)			getter: func(k string) (interface{}, error) {			value: true,			key:   "test_bool",		{		},			expected: int64(42),			},				return accessor.GetInt(k)			getter: func(k string) (interface{}, error) {			value: 42,			key:   "test_int",		{		},			expected: "Hello World",			},				return accessor.GetString(k)			getter: func(k string) (interface{}, error) {			value: "Hello World",			key:   "test_string",		{	}{		expected interface{}		getter   func(string) (interface{}, error)		value    interface{}		key      string	tests := []struct {	// Test setting and getting different types	suite.NotNil(accessor)	suite.NoError(err)	accessor, err := suite.manager.GetAccessor(tenantID, organizationID)	organizationID := "accessor-test-org"	tenantID := int64(1)func (suite *SettingsTestSuite) TestSettingsAccessor() {// TestSettingsAccessor tests the accessor functionality}	suite.True(companyIndex < billingIndex, "Company should be initialized before billing")	}		}			billingIndex = i		if moduleName == "billing" {		}			companyIndex = i		if moduleName == "company" {	for i, moduleName := range resolved {	billingIndex := -1	companyIndex := -1	// Verify company comes before billing (billing depends on company)	suite.NotEmpty(resolved)	suite.NoError(err)	resolved, err := suite.registry.ResolveDependencies()	// Test dependency resolution	suite.GreaterOrEqual(len(schemas), 3) // At least company, invoice, billing	schemas := suite.registry.GetAllSchemas()	// Test GetAllSchemas	suite.Equal(entities.DomainCompany, schema.Domain)	suite.Equal("company", schema.ModuleName)	suite.NoError(err)	schema, err := suite.registry.GetSchema("company")	// Test GetSchema	suite.NotNil(provider)	suite.NoError(err)	provider, err := suite.registry.GetProvider("company")	// Test GetProviderfunc (suite *SettingsTestSuite) TestSettingsRegistry() {// TestSettingsRegistry tests the registry functionality}	suite.Error(err) // Should not exist	_, err = suite.repo.GetSetting(tenantID, organizationID, entities.DomainCompany, "company_email")	suite.NoError(err)	err = suite.repo.DeleteSetting(tenantID, organizationID, entities.DomainCompany, "company_email")	// Test DeleteSetting	suite.Len(settings, 2)	suite.NoError(err)	settings, err := suite.repo.GetSettings(tenantID, organizationID, entities.DomainCompany)	suite.NoError(err)	err = suite.repo.CreateSetting(setting2)	}		Type:           entities.SettingTypeString,		Value:          "test@example.com",		Key:            "company_email",		Domain:         entities.DomainCompany,		OrganizationID: organizationID,		TenantID:       tenantID,	setting2 := &entities.Setting{	// Test GetSettings (multiple)	suite.Equal("Updated Company", updated.Value)	suite.NoError(err)	updated, err := suite.repo.GetSetting(tenantID, organizationID, entities.DomainCompany, "company_name")	suite.NoError(err)	err = suite.repo.UpdateSetting(retrieved)	retrieved.Value = "Updated Company"	// Test UpdateSetting	suite.Equal(entities.SettingTypeString, retrieved.Type)	suite.Equal("Test Company", retrieved.Value)	suite.NoError(err)	retrieved, err := suite.repo.GetSetting(tenantID, organizationID, entities.DomainCompany, "company_name")	// Test GetSetting	suite.NotZero(setting.ID)	suite.NoError(err)	err := suite.repo.CreateSetting(setting)	}		Type:           entities.SettingTypeString,		Value:          "Test Company",		Key:            "company_name",		Domain:         entities.DomainCompany,		OrganizationID: organizationID,		TenantID:       tenantID,	setting := &entities.Setting{	// Test CreateSetting	organizationID := "test-org"	tenantID := int64(1)func (suite *SettingsTestSuite) TestSettingsRepository() {// TestSettingsRepository tests the repository layer}	}		suite.Require().NoError(err)		err := suite.registry.RegisterProvider(module)	for _, module := range modules {	}		billingSettings.NewBillingSettingsProvider(),		invoiceSettings.NewInvoiceSettingsProvider(),		companySettings.NewCompanySettingsProvider(),	modules := []interface{}{func (suite *SettingsTestSuite) registerTestModules() {// registerTestModules registers modules for testing}	}		sqlDB.Close()		sqlDB, _ := suite.db.DB()	if suite.db != nil {func (suite *SettingsTestSuite) TearDownSuite() {// TearDownSuite runs once after all tests in the suite}	suite.Require().NoError(err)	err = suite.manager.Initialize()	// Initialize the manager	suite.registerTestModules()	// Register test modules	suite.manager = manager.NewSettingsManager(suite.repo, suite.registry)	suite.registry = registry.NewSettingsRegistry()	suite.repo = repository.NewSettingsRepository(db)	suite.db = db	// Initialize components	suite.Require().NoError(err)	err = repository.AutoMigrateSettingsTables(db)	// Auto-migrate tables	suite.Require().NoError(err)	db, err := gorm.Open(sqlite.Open(":memory:"), &gorm.Config{})	// Initialize in-memory SQLite database for testingfunc (suite *SettingsTestSuite) SetupSuite() {// SetupSuite runs once before all tests in the suite}	manager  *manager.SettingsManager	registry *registry.SettingsRegistry	repo     *repository.SettingsRepository	db       *gorm.DB	suite.Suitetype SettingsTestSuite struct {// SettingsTestSuite provides a test suite for the entire settings system)	billingSettings "github.com/ae-base-server/modules/billing/settings"	invoiceSettings "github.com/ae-base-server/modules/invoice/settings"	companySettings "github.com/ae-base-server/modules/company/settings"