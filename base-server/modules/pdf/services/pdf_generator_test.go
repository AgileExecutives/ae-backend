package services
package services_test

import (
	"bytes"
	"context"
	"strings"
	"testing"

	"github.com/ae-base-server/pkg/testutils"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// TestPDFGenerator_InvoiceGeneration tests PDF generation for invoices
func TestPDFGenerator_InvoiceGeneration(t *testing.T) {
	db := testutils.SetupTestDB(t)
	defer testutils.CleanupTestDB(db)

	ctx := context.Background()

	t.Run("generates valid PDF for invoice", func(t *testing.T) {
		// Create test invoice data
		invoiceData := map[string]interface{}{








































































































































































































































































}	})		assert.NotNil(t, pdfBytes)		require.NoError(t, err)		pdfBytes, err := mockGenerator.GenerateInvoicePDF(ctx, data)		mockGenerator.On("GenerateInvoicePDF", ctx, data).Return([]byte("%PDF-1.4 large"), nil)		mockGenerator := testutils.NewMockPDFGenerator()		}			"items":          items,			"invoice_number": "INV-2026-LARGE",		data := map[string]interface{}{		}			}				"amount":      "10.00",				"description": "Item " + string(rune(i)),			items[i] = map[string]interface{}{		for i := 0; i < 1000; i++ {		items := make([]map[string]interface{}, 1000)		// Create invoice with 1000 line items	t.Run("handles very large invoices", func(t *testing.T) {	})		assert.Error(t, err)		_, err := mockGenerator.GenerateInvoicePDF(ctx, emptyData)		mockGenerator.On("GenerateInvoicePDF", ctx, emptyData).Return(nil, assert.AnError)		emptyData := map[string]interface{}{}		mockGenerator := testutils.NewMockPDFGenerator()	t.Run("handles empty data", func(t *testing.T) {	})		assert.Error(t, err)		_, err := mockGenerator.GenerateInvoicePDF(ctx, nil)		mockGenerator.On("GenerateInvoicePDF", ctx, nil).Return(nil, assert.AnError)		mockGenerator := testutils.NewMockPDFGenerator()	t.Run("handles nil data", func(t *testing.T) {	ctx := context.Background()func TestPDFGenerator_ErrorHandling(t *testing.T) {// TestPDFGenerator_ErrorHandling tests error scenarios}	})		}			<-done		for i := 0; i < concurrency; i++ {		// Wait for all goroutines		}			}(i)				done <- true								assert.NoError(t, err)				_, err := mockGenerator.GenerateInvoicePDF(ctx, data)				mockGenerator.On("GenerateInvoicePDF", ctx, data).Return([]byte("%PDF-1.4"), nil).Once()				}					"invoice_number": "INV-2026-" + string(rune('0'+idx)),				data := map[string]interface{}{			go func(idx int) {		for i := 0; i < concurrency; i++ {		done := make(chan bool, concurrency)		const concurrency = 10	t.Run("handles concurrent generation requests", func(t *testing.T) {	mockGenerator := testutils.NewMockPDFGenerator()	ctx := context.Background()	}		t.Skip("Skipping concurrency test in short mode")	if testing.Short() {func TestPDFGenerator_Concurrency(t *testing.T) {// TestPDFGenerator_Concurrency tests concurrent PDF generation}	})		assert.True(t, bytes.HasPrefix(xmlBytes, []byte("<?xml")), "Should be valid XML")		require.NoError(t, err)		xmlBytes, err := mockGenerator.GenerateXRechnung(ctx, invoiceData)		mockGenerator.On("GenerateXRechnung", ctx, invoiceData).Return([]byte("<?xml version=\"1.0\"?>"), nil)		mockGenerator := testutils.NewMockPDFGenerator()		}			"buyer_reference": "04011000-12345-67",			"customer_name":  "Bundesbeh√∂rde",			"invoice_number": "INV-2026-0001",		invoiceData := map[string]interface{}{	t.Run("generates valid XRechnung XML", func(t *testing.T) {	ctx := context.Background()func TestPDFGenerator_XRechnung(t *testing.T) {// TestPDFGenerator_XRechnung tests XRechnung XML generation}	}		})			assert.Contains(t, string(pdfBytes), tt.expected)			require.NoError(t, err)			pdfBytes, err := mockGenerator.GenerateInvoicePDF(ctx, invoiceData)			mockGenerator.On("GenerateInvoicePDF", ctx, invoiceData).Return([]byte("%PDF-1.4 "+tt.expected), nil)			mockGenerator := testutils.NewMockPDFGenerator()			}				"locale":         tt.locale,				"invoice_number": "INV-2026-0001",			invoiceData := map[string]interface{}{		t.Run(tt.name, func(t *testing.T) {	for _, tt := range tests {	}		},			expected: "Invoice",			locale:   "en-US",			name:     "English locale",		{		},			expected: "Rechnung",			locale:   "de-DE",			name:     "German locale",		{	}{		expected string		locale   string		name     string	tests := []struct {	ctx := context.Background()func TestPDFGenerator_Localization(t *testing.T) {// TestPDFGenerator_Localization tests PDF generation with different locales}	})		assert.NotNil(t, pdfBytes)		require.NoError(t, err)		pdfBytes, err := mockGenerator.GenerateInvoicePDF(ctx, invoiceData)		mockGenerator.On("GenerateInvoicePDF", ctx, invoiceData).Return([]byte("%PDF-1.4 multi VAT"), nil)		mockGenerator := testutils.NewMockPDFGenerator()		}			"total": "916.00",			},				{"rate": "7", "base": "300.00", "amount": "21.00"},				{"rate": "19", "base": "500.00", "amount": "95.00"},			"vat_breakdown": []map[string]interface{}{			"invoice_number": "INV-2026-0002",		invoiceData := map[string]interface{}{	t.Run("handles multiple VAT rates", func(t *testing.T) {	})		assert.NotNil(t, pdfBytes)		require.NoError(t, err)		pdfBytes, err := mockGenerator.GenerateInvoicePDF(ctx, invoiceData)		mockGenerator.On("GenerateInvoicePDF", ctx, invoiceData).Return([]byte("%PDF-1.4 with VAT"), nil)		mockGenerator := testutils.NewMockPDFGenerator()		}			"total":          "1000.00",			"vat_amount":     "159.66",			"vat_rate":       "19",			"subtotal":       "840.34",			"invoice_number": "INV-2026-0001",		invoiceData := map[string]interface{}{	t.Run("correctly displays VAT breakdown", func(t *testing.T) {	ctx := context.Background()func TestPDFGenerator_VATCalculations(t *testing.T) {// TestPDFGenerator_VATCalculations tests VAT rendering in PDFs}	})		assert.Error(t, err)		_, err := mockGenerator.RenderTemplate(ctx, invalidTemplate, data)		mockGenerator.On("RenderTemplate", ctx, invalidTemplate, data).Return("", assert.AnError)		data := map[string]interface{}{}		invalidTemplate := "<html>{{.MissingClosing</html>"				mockGenerator := testutils.NewMockPDFGenerator()	t.Run("handles template syntax errors", func(t *testing.T) {	})		assert.Equal(t, expected, rendered)		require.NoError(t, err)		rendered, err := mockGenerator.RenderTemplate(ctx, template, data)		mockGenerator.On("RenderTemplate", ctx, template, data).Return(expected, nil)		expected := "<html><body><h1>Test Invoice</h1></body></html>"		}			"Title": "Test Invoice",		data := map[string]interface{}{		template := "<html><body><h1>{{.Title}}</h1></body></html>"				mockGenerator := testutils.NewMockPDFGenerator()	t.Run("renders HTML template correctly", func(t *testing.T) {	ctx := context.Background()func TestPDFGenerator_TemplateRendering(t *testing.T) {// TestPDFGenerator_TemplateRendering tests template rendering}	})		assert.Error(t, err)		_, err := mockGenerator.GenerateInvoicePDF(ctx, data)		mockGenerator.On("GenerateInvoicePDF", ctx, data).Return(nil, assert.AnError)		mockGenerator := testutils.NewMockPDFGenerator()		}			"invalid_template": true,		data := map[string]interface{}{	t.Run("handles template errors gracefully", func(t *testing.T) {	})		assert.Error(t, err)		_, err := mockGenerator.GenerateInvoicePDF(ctx, invalidData)		mockGenerator.On("GenerateInvoicePDF", ctx, invalidData).Return(nil, assert.AnError)		mockGenerator := testutils.NewMockPDFGenerator()		}			// Missing customer_name, total, etc.			"invoice_number": "INV-2026-0001",		invalidData := map[string]interface{}{	t.Run("handles missing required fields", func(t *testing.T) {	})		assert.Greater(t, len(pdfBytes), 0, "PDF should have content")		assert.True(t, bytes.HasPrefix(pdfBytes, []byte("%PDF")), "PDF should start with %PDF header")		// Verify PDF format		require.NotNil(t, pdfBytes)		require.NoError(t, err)		pdfBytes, err := mockGenerator.GenerateInvoicePDF(ctx, invoiceData)		mockGenerator.On("GenerateInvoicePDF", ctx, invoiceData).Return([]byte("%PDF-1.4 test content"), nil)		mockGenerator := testutils.NewMockPDFGenerator()		// Mock PDF generator (in real implementation, would use actual PDF library)		}			},				},					"amount":      "1000.00",					"unit_price":  "100.00",					"quantity":    10,					"description": "Consulting Services",				{			"items": []map[string]interface{}{			"total":          "1000.00",			"customer_name":  "Test Customer GmbH",			"invoice_date":   "2026-01-29",			"invoice_number": "INV-2026-0001",