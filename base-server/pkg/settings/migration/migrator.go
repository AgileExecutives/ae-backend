package migration
package migration

import (
	"fmt"






































































































































































































































































































}	return "20260109_120000"	// This would return a proper timestamp - simplified for examplefunc getCurrentTimestamp() string {}	return make(map[string]interface{})	}		}			return m		if m, ok := val.(map[string]interface{}); ok {	if val, ok := data[key]; ok && val != nil {func getMap(data map[string]interface{}, key string) map[string]interface{} {}	return false	}		}			return b		if b, ok := val.(bool); ok {	if val, ok := data[key]; ok && val != nil {func getBool(data map[string]interface{}, key string) bool {}	return 0.0	}		}			return float64(i64)		if i64, ok := val.(int64); ok {		}			return float64(i)		if i, ok := val.(int); ok {		}			return f		if f, ok := val.(float64); ok {	if val, ok := data[key]; ok && val != nil {func getFloat64(data map[string]interface{}, key string) float64 {}	return 0	}		}			return int(f64)		if f64, ok := val.(float64); ok {		}			return int(i64)		if i64, ok := val.(int64); ok {		}			return i		if i, ok := val.(int); ok {	if val, ok := data[key]; ok && val != nil {func getInt(data map[string]interface{}, key string) int {}	return ""	}		}			return str		if str, ok := val.(string); ok {	if val, ok := data[key]; ok && val != nil {func getString(data map[string]interface{}, key string) string {// Helper functions}	return nil	}		}			log.Printf("Dropped column: %s", column)		} else {			// Continue with other columns			log.Printf("Failed to drop column %s: %v", column, err)		if err := m.db.Exec(query).Error; err != nil {		query := fmt.Sprintf("ALTER TABLE organizations DROP COLUMN IF EXISTS %s", column)	for _, column := range settingsColumns {	}		"invoice_content",		"additional_payment_methods",		"amount_format",		"time_format",		"date_format",		"locale",		"default_vat_exempt",		"default_vat_rate",		"second_reminder_days",		"first_reminder_days",		"payment_due_days",		"invoice_number_prefix",		"invoice_number_format",		"line_item_double_unit_text",		"line_item_single_unit_text",		"extra_efforts_config",		"extra_efforts_billing_mode",		"unit_price", 		"tax_rate",	settingsColumns := []string{	// List of columns to remove (settings-related columns)	log.Println("Make sure you have a backup before proceeding")	log.Println("WARNING: This will remove settings columns from organization table")func (m *SettingsMigrator) CleanupOrganizationSettings() error {// CleanupOrganizationSettings removes migrated settings from organization table (use with caution)}	return nil	log.Println("Migration validation completed successfully")	}		}			}				log.Printf("WARNING: No settings found for tenant %d, domain %s", tenantID, domain)			if count == 0 {						}				return fmt.Errorf("failed to validate settings for tenant %d, domain %s: %w", tenantID, domain, err)			if err := m.db.Table("settings").Where("tenant_id = ? AND domain = ?", tenantID, domain).Count(&count).Error; err != nil {			var count int64		for _, domain := range expectedDomains {	for _, tenantID := range tenantIDs {	}		entities.DomainLocalization,		entities.DomainBilling,		entities.DomainInvoicing,		entities.DomainCompany,	expectedDomains := []entities.SettingsDomain{	}		return fmt.Errorf("failed to get tenant IDs: %w", err)	if err := m.db.Table("organizations").Select("DISTINCT tenant_id").Find(&tenantIDs).Error; err != nil {	var tenantIDs []uint	// Check that all domains are present for each tenant	}		return fmt.Errorf("migration validation failed: tenant count mismatch")		log.Printf("WARNING: Tenant count mismatch - Organizations: %d, Settings: %d", tenantCount, settingsCount)	if tenantCount != settingsCount {	}		return fmt.Errorf("failed to count settings tenants: %w", err)	if err := m.db.Table("settings").Select("DISTINCT tenant_id").Count(&settingsCount).Error; err != nil {	var settingsCount int64	}		return fmt.Errorf("failed to count tenants: %w", err)	if err := m.db.Table("organizations").Select("DISTINCT tenant_id").Count(&tenantCount).Error; err != nil {	var tenantCount int64	log.Println("Validating migration...")func (m *SettingsMigrator) ValidateMigration() error {// ValidateMigration validates that the migration was successful}	return nil	log.Printf("Created backup table: %s", backupTableName)	}		return fmt.Errorf("failed to create backup table: %w", err)	if err := m.db.Exec(query).Error; err != nil {	query := fmt.Sprintf("CREATE TABLE %s AS SELECT * FROM organizations", backupTableName)		backupTableName := "organizations_backup_" + getCurrentTimestamp()func (m *SettingsMigrator) CreateBackupOrganizationTable() error {// CreateBackupOrganizationTable creates a backup of the current organization table}	})		return nil		}			return fmt.Errorf("failed to migrate localization settings: %w", err)		if err := txService.SetLocalizationSettings(tenantID, localizationSettings); err != nil {		}			AmountFormat: getString(orgData, "amount_format"),			TimeFormat:   getString(orgData, "time_format"),			DateFormat:   getString(orgData, "date_format"),			Locale:       getString(orgData, "locale"),		localizationSettings := entities.LocalizationSettings{		// Migrate localization settings		}			return fmt.Errorf("failed to migrate billing settings: %w", err)		if err := txService.SetBillingSettings(tenantID, billingSettings); err != nil {		}			LineItemDoubleUnitText: getString(orgData, "line_item_double_unit_text"),			LineItemSingleUnitText: getString(orgData, "line_item_single_unit_text"),			TaxRate:                getFloat64(orgData, "tax_rate"),			UnitPrice:              getFloat64(orgData, "unit_price"),			Config:                 getMap(orgData, "extra_efforts_config"),			Mode:                   getString(orgData, "extra_efforts_billing_mode"),		billingSettings := entities.BillingSettings{		// Migrate billing settings		}			return fmt.Errorf("failed to migrate invoicing settings: %w", err)		if err := txService.SetInvoicingSettings(tenantID, invoicingSettings); err != nil {		}			InvoiceContent:     getMap(orgData, "invoice_content"),			DefaultVATExempt:   getBool(orgData, "default_vat_exempt"),			DefaultVATRate:     getFloat64(orgData, "default_vat_rate"),			SecondReminderDays: getInt(orgData, "second_reminder_days"),			FirstReminderDays:  getInt(orgData, "first_reminder_days"),			PaymentDueDays:     getInt(orgData, "payment_due_days"),			NumberPrefix:       getString(orgData, "invoice_number_prefix"),			NumberFormat:       getString(orgData, "invoice_number_format"),		invoicingSettings := entities.InvoicingSettings{		// Migrate invoicing settings		}			return fmt.Errorf("failed to migrate company settings: %w", err)		if err := txService.SetCompanySettings(tenantID, companySettings); err != nil {		}			AdditionalPaymentMethods: getMap(orgData, "additional_payment_methods"),			BankAccountIBAN:          getString(orgData, "bankaccount_iban"),			BankAccountBIC:           getString(orgData, "bankaccount_bic"),			BankAccountBank:          getString(orgData, "bankaccount_bank"),			BankAccountOwner:         getString(orgData, "bankaccount_owner"),			TaxUstID:                 getString(orgData, "tax_ustid"),			TaxID:                    getString(orgData, "tax_id"),			Phone:                    getString(orgData, "phone"),			Email:                    getString(orgData, "email"),			City:                     getString(orgData, "city"),			Zip:                      getString(orgData, "zip"),			StreetAddress:            getString(orgData, "street_address"),			OwnerTitle:               getString(orgData, "owner_title"),			OwnerName:                getString(orgData, "owner_name"),			Name:                     getString(orgData, "name"),		companySettings := entities.CompanySettings{		// Migrate company settings		txService := services.NewSettingsService(tx)		// Create temporary service using transaction	return m.db.Transaction(func(tx *gorm.DB) error {func (m *SettingsMigrator) MigrateOrganizationSettings(tenantID uint, orgData map[string]interface{}) error {// MigrateOrganizationSettings migrates a single organization's settings}	return nil	log.Println("Migration completed")	}		log.Printf("Successfully migrated organization for tenant %d", tenantID)		}			continue			log.Printf("Failed to migrate organization for tenant %d: %v", tenantID, err)		if err := m.MigrateOrganizationSettings(tenantID, org); err != nil {		log.Printf("Migrating organization for tenant %d...", tenantID)		}			continue			log.Printf("Skipping organization %d: invalid tenant_id", i)		if !ok {		tenantID, ok := org["tenant_id"].(uint)	for i, org := range organizations {	// Migrate each organization	log.Printf("Found %d organizations to migrate", len(organizations))	}		return fmt.Errorf("failed to fetch organizations: %w", err)	if err := m.db.Table("organizations").Find(&organizations).Error; err != nil {	var organizations []map[string]interface{}	// Get all organizations	log.Println("Starting migration of organization settings...")func (m *SettingsMigrator) MigrateAllOrganizations() error {// MigrateAllOrganizations migrates all existing organizations to the new settings system}	}		settingsService: services.NewSettingsService(db),		db:              db,	return &SettingsMigrator{func NewSettingsMigrator(db *gorm.DB) *SettingsMigrator {// NewSettingsMigrator creates a new settings migrator}	settingsService *services.SettingsService	db              *gorm.DBtype SettingsMigrator struct {// SettingsMigrator handles migration from organization table to new settings system)	"gorm.io/gorm"	"github.com/ae-base-server/pkg/settings/services"	"github.com/ae-base-server/pkg/settings/entities"		"log"